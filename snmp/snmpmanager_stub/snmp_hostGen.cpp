/*
* If not stated otherwise in this file or this component's LICENSE file the
* following copyright and licenses apply:
*
* Copyright 2011 RDK Management
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.table_data.conf 15999 2007-03-25 22:32:02Z dts12 $
 */
#include <sstream>
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "snmp_host.h"
#include "host_enums.h"
#include "utilityMacros.h"
#include "vl_ocStbHost_GetData.h"
#include "persistentconfig.h"
#include "rdk_debug.h"
#include "rmf_osal_mem.h"

#if USE_SYSRES_MLT
#include "rpl_new.h"
#endif

#define vlStrCpy(pDest, pSrc, nDestCapacity)            \
            strcpy(pDest, pSrc)

#define vlMemCpy(pDest, pSrc, nCount, nDestCapacity)            \
                                                  memcpy(pDest, pSrc, nCount)
                                                  
#define VL_ZERO_MEMORY(x) \
    memset(&x,0,sizeof(x))
    
using namespace std;
/** Initializes the host module */
void
init_host(void)
{
    /*
     * here we initialize all the tables we're planning on supporting
     */

/*    initialize_table_hrStorageTable();
    initialize_table_hrDeviceTable();
    initialize_table_hrProcessorTable();*/
    initialize_table_hrSWRunTable();
    initialize_table_hrSWRunPerfTable();



    //May be later this modules can be add
    /*
    initialize_table_hrNetworkTable();
    initialize_table_hrPrinterTable();
    initialize_table_hrDiskStorageTable();
    initialize_table_hrPartitionTable();
    initialize_table_hrFSTable();
    initialize_table_hrSWInstalledTable();*/

}

/** Initialize the hrStorageTable table by defining its contents and how it's structured */
void
initialize_table_hrStorageTable(void)
{
    static oid      hrStorageTable_oid[] = { 1, 3, 6, 1, 2, 1, 25, 2, 3 };
    size_t          hrStorageTable_oid_len =
        OID_LENGTH(hrStorageTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata  *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache  *cache;

    reg =
        netsnmp_create_handler_registration("hrStorageTable",
                                            hrStorageTable_handler,
                                            hrStorageTable_oid,
                                            hrStorageTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_data = netsnmp_tdata_create_table("hrStorageTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrStorageIndex */
                                     0);

    table_info->min_column = COLUMN_HRSTORAGEINDEX;
    table_info->max_column = COLUMN_HRSTORAGEALLOCATIONFAILURES;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRSTORAGETABLE_TIMEOUT,
                                 hrStorageTable_load, hrStorageTable_free,
                                 hrStorageTable_oid,
                                 hrStorageTable_oid_len);
    cache->magic = (void *) table_data;
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET |
            NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | NETSNMP_CACHE_DONT_FREE_EXPIRED |
            NETSNMP_CACHE_DONT_AUTO_RELEASE;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_get(cache),
                                  "hrStorageTable");

        /*
         * Initialise the contents of the table here
         */
    if(0 == hrStorageTable_load(cache,table_data))
    {
        //snmpTargetParamsTable_load"
        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", " ERROR:: hrStorageTable Not yet table initialise here \n");
    }
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
  hrStorageTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table_data = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;

    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrStorageTable_load :: Start  \n");
    bool replace_table = false;
    int count = 0;
    if(netsnmp_tdata_row_first(table_data))
    {
        replace_table = true;
    }

    /**Dummy Data dec . taking 2times**/
    struct hrStorageTable_entry  hrSotageE[2];
    hrSotageE[0].hrStorageIndex = 1;
    hrSotageE[0].hrStorageIndex_I = 1; //same as Index

    hrSotageE[0].hrStorageType_len = (sizeof(HR_StorageTypes[hrStorageRam])/(sizeof(oid)));
    //  SNMP_DEBUGPRINT("\nocStbHostAVInterfaceType===== 1\n");
    vlMemCpy(hrSotageE[0].hrStorageType, HR_StorageTypes[hrStorageRam],
             hrSotageE[0].hrStorageType_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    hrSotageE[0].hrStorageDescr_len = strlen("hrStorageRam") ;
    vlMemCpy(hrSotageE[0].hrStorageDescr, "hrStorageRam",
             hrSotageE[0].hrStorageDescr_len,
             API_CHRMAX);
    hrSotageE[0].hrStorageAllocationUnits = 1024;
    hrSotageE[0].hrStorageSize = 10460;
    hrSotageE[0].old_hrStorageSize = 0;
    hrSotageE[0].hrStorageUsed = 84436;
    hrSotageE[0].hrStorageAllocationFailures = 0;
    //Item 2
    hrSotageE[1].hrStorageIndex = 3;
    hrSotageE[1].hrStorageIndex_I = 3; //same as Index

    hrSotageE[1].hrStorageType_len = (sizeof(HR_StorageTypes[hrStorageVirtualMemory])/(sizeof(oid)));
    //  SNMP_DEBUGPRINT("\nocStbHostAVInterfaceType===== 1\n");
    vlMemCpy(hrSotageE[1].hrStorageType, HR_StorageTypes[hrStorageVirtualMemory],
             hrSotageE[1].hrStorageType_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    hrSotageE[1].hrStorageDescr_len = strlen("hrStorageVirtualMemory") ;
    vlMemCpy(hrSotageE[1].hrStorageDescr, "hrStorageVirtualMemory",
             hrSotageE[1].hrStorageDescr_len,
             API_CHRMAX);
    hrSotageE[1].hrStorageAllocationUnits = 1024;
    hrSotageE[1].hrStorageSize = 10460;
    hrSotageE[1].old_hrStorageSize = 0;
    hrSotageE[1].hrStorageUsed = 84436;
    hrSotageE[1].hrStorageAllocationFailures = 0;

    /** Dummy Data Ends............made a dynamic call to get real values**/
    int Maxsize =2;
    for( int nsizelist = 0; nsizelist < Maxsize; nsizelist++)
    {
        if(replace_table)
        {
            replace_table = false;
            Table_free(table_data);

        }
        hrStorageTable_createEntry_allData(table_data, &hrSotageE[nsizelist]);
    }

#if 0
    if(Maxsize == 0)
    {
        Table_free(table_data);
        struct hrStorageTable_entry  hrSotageE;
        memset(&hrSotageE, 0, sizeof(struct hrStorageTable_entry));
        hrStorageTable_createEntry_allData(table_data, &hrSotageE);
    }
#endif
    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrStorageTable_load:: End   :::  \n");
    return 1;
}

int hrStorageTable_createEntry_allData(netsnmp_tdata * table_data, struct hrStorageTable_entry *hrSotageE)
  {
      int i = 0;
      SNMP_DEBUGPRINT("\n hrStorageTable_createEntry_allData ::Start \n");
      struct hrStorageTable_entry *entry;
      netsnmp_tdata_row *row;
      entry = SNMP_MALLOC_TYPEDEF(struct hrStorageTable_entry);
      if (!entry)
          return 0;

      row = netsnmp_tdata_create_row();
      if (!row) {
          SNMP_FREE(entry);
          return 0;
      }
      row->data = entry;
    /*
      * Index values
    */
      entry->hrStorageIndex = hrSotageE->hrStorageIndex;
      entry->hrStorageIndex_I = hrSotageE->hrStorageIndex_I; //same as Index

      entry->hrStorageType_len = hrSotageE->hrStorageType_len;
    //  SNMP_DEBUGPRINT("\nocStbHostAVInterfaceType===== 1\n");
      vlMemCpy(entry->hrStorageType, hrSotageE->hrStorageType,
               entry->hrStorageType_len * sizeof(oid),
               MAX_IOD_LENGTH * sizeof(oid));
      entry->hrStorageDescr_len = hrSotageE->hrStorageDescr_len ;
      vlMemCpy(entry->hrStorageDescr, hrSotageE->hrStorageDescr,
               entry->hrStorageDescr_len,
               CHRMAX);
      entry->hrStorageAllocationUnits = hrSotageE->hrStorageAllocationUnits;
      entry->hrStorageSize = hrSotageE->hrStorageSize;
      entry->old_hrStorageSize = hrSotageE->old_hrStorageSize;
      entry->hrStorageUsed =hrSotageE->hrStorageUsed;
      entry->hrStorageAllocationFailures =hrSotageE->hrStorageAllocationFailures;

      netsnmp_tdata_row_add_index(row, ASN_UNSIGNED,
                                  &(entry->hrStorageIndex),
                                  sizeof(entry->hrStorageIndex));
      netsnmp_tdata_add_row(table_data, row);

      RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrStorageTable_createEntry_allData ::END \n");
      return 1;
}

void
   hrStorageTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    /*netsnmp_tdata_row *this;

    while           ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
}*/
}
/** handles requests for the hrStorageTable table */

int
  hrStorageTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    netsnmp_tdata * vl_table_data; //add
    netsnmp_tdata_row *vl_row;  //add
    vl_row = NULL; //add
    struct hrStorageTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            //table_entry = (struct hrStorageTable_entry *)                netsnmp_tdata_extract_entry(request);
            /*changed due to wrong values in retriving first element of the Table*/
            VL_SNMP_PREPARE_AND_CHECK_TABLE_GET_REQUEST(hrStorageTable_entry);

            switch (table_info->colnum) {
            case COLUMN_HRSTORAGEINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrStorageIndex);
                break;
            case COLUMN_HRSTORAGETYPE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->
                                         hrStorageType,
                                         table_entry->hrStorageType_len * sizeof(oid));
                break;
            case COLUMN_HRSTORAGEDESCR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrStorageDescr,
                                         table_entry->hrStorageDescr_len);
                break;
            case COLUMN_HRSTORAGEALLOCATIONUNITS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrStorageAllocationUnits);
                break;
            case COLUMN_HRSTORAGESIZE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrStorageSize);
                break;
            case COLUMN_HRSTORAGEUSED:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrStorageUsed);
                break;
            case COLUMN_HRSTORAGEALLOCATIONFAILURES:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_COUNTER,
                                           table_entry->
                                           hrStorageAllocationFailures);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRSTORAGESIZE:
                /*
                 * or possibly 'netsnmp_check_vb_int_range'
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrStorageTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRSTORAGESIZE:
                table_entry->old_hrStorageSize =
                    table_entry->hrStorageSize;
                table_entry->hrStorageSize =
                    *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrStorageTable_entry *)
                netsnmp_tdata_extract_entry(request);
            netsnmp_tdata_extract_row(request);
            netsnmp_tdata_extract_table(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRSTORAGESIZE:
                table_entry->hrStorageSize =
                    table_entry->old_hrStorageSize;
                table_entry->old_hrStorageSize = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}



/** Initialize the hrDeviceTable table by defining its contents and how it's structured */
void
                initialize_table_hrDeviceTable(void) {
    static oid      hrDeviceTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 2};
    size_t          hrDeviceTable_oid_len = OID_LENGTH(hrDeviceTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrDeviceTable",
                                            hrDeviceTable_handler,
                                            hrDeviceTable_oid,
                                            hrDeviceTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrDeviceTable", 0);
//    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(netsnmp_table_registration_info), (void**)&table_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
                                     0);

    table_info->min_column = COLUMN_HRDEVICEINDEX;
    table_info->max_column = COLUMN_HRDEVICEERRORS;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRDEVICETABLE_TIMEOUT,
                                 hrDeviceTable_load, hrDeviceTable_free,
                                 hrDeviceTable_oid, hrDeviceTable_oid_len);
        cache->magic = (void *) table_data;
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET |                NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | NETSNMP_CACHE_DONT_FREE_EXPIRED | NETSNMP_CACHE_DONT_AUTO_RELEASE;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_get(cache),
                                  "hrDeviceTable");

        /*
         * Initialise the contents of the table here
         */
    if(0 == hrDeviceTable_load(cache,table_data))
    {
        //snmpTargetParamsTable_load"
        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", " ERROR:: hrDeviceTable_load Not yet table initialise here \n");
    }
}


/*
 * Example cache handling - set up table_data list from a suitable file
 */
struct hrDeviceTable_entry  hrDeviceE[2];
int
                hrDeviceTable_load(netsnmp_cache * cache, void *vmagic) {

    netsnmp_tdata * table_data = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;

    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrStorageTable_load :: Start    :::  \n");
    bool replace_table = false;
    int count = 0;
    if(netsnmp_tdata_row_first(table_data))
    {
        replace_table = true;
    }

    /**Dummy Data dec . taking 2times**/

    hrDeviceE[0].hrDeviceIndex = 3; //It can be any number but for reference to hrDeviceProcessor we have given 3
    hrDeviceE[0].hrDeviceIndex_I = 3; //same as Index

    hrDeviceE[0].hrDeviceType_len = (sizeof(HR_DeviceTypes[hrDeviceProcessor])/(sizeof(oid)));
    vlMemCpy(hrDeviceE[0].hrDeviceType, HR_DeviceTypes[hrDeviceProcessor],
             hrDeviceE[0].hrDeviceType_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    hrDeviceE[0].hrDeviceDescr_len = strlen("hrDeviceProcessor") ;
    vlMemCpy(hrDeviceE[0].hrDeviceDescr, "hrDeviceProcessor",
             hrDeviceE[0].hrDeviceDescr_len,
             API_CHRMAX);
    hrDeviceE[0].hrDeviceID_len = (sizeof(HR_DeviceTypes[hrDeviceTape])/(sizeof(oid)));
    vlMemCpy(hrDeviceE[0].hrDeviceID, HR_DeviceTypes[hrDeviceTape],
             hrDeviceE[0].hrDeviceID_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    hrDeviceE[0].hrDeviceStatus = HRDEVICESTATUS_RUNNING;
    hrDeviceE[0].hrDeviceErrors = 0;

    //Item 2
    hrDeviceE[1].hrDeviceIndex = 6;  //hrDeviceProcessor is number 6
    hrDeviceE[1].hrDeviceIndex_I = 6; //same as Index

    hrDeviceE[1].hrDeviceType_len = (sizeof(HR_DeviceTypes[hrDeviceDiskStorage])/(sizeof(oid)));
    vlMemCpy(hrDeviceE[1].hrDeviceType, HR_DeviceTypes[hrDeviceDiskStorage],
             hrDeviceE[1].hrDeviceType_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    hrDeviceE[1].hrDeviceDescr_len = strlen("hrDeviceDiskStorage") ;
    vlMemCpy(hrDeviceE[1].hrDeviceDescr, "hrDeviceDiskStorage",
             hrDeviceE[1].hrDeviceDescr_len,
             API_CHRMAX);
    hrDeviceE[1].hrDeviceID_len = (sizeof(HR_DeviceTypes[hrDeviceTape])/(sizeof(oid)));
    vlMemCpy(hrDeviceE[1].hrDeviceID, HR_DeviceTypes[hrDeviceTape],
             hrDeviceE[1].hrDeviceID_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    hrDeviceE[1].hrDeviceStatus = HRDEVICESTATUS_RUNNING;
    hrDeviceE[1].hrDeviceErrors = 0;


    /** Dummy Data Ends............made a dynamic call to get real values**/
    int Maxsize =2;
    for( int nsizelist = 0; nsizelist < Maxsize; nsizelist++)
    {
        if(replace_table)
        {
            replace_table = false;
            Table_free(table_data);

        }
        hrDeviceTable_createEntry_allData(table_data, &hrDeviceE[nsizelist]);
    }
#if 0
    if(Maxsize == 0)
    {
        Table_free(table_data);
        struct hrDeviceTable_entry  hrDeviceE;
        memset(&hrDeviceE, 0, sizeof(struct hrDeviceTable_entry));
        hrDeviceTable_createEntry_allData(table_data, &hrDeviceE);
    }
#endif 
    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrStorageTable_load:: End   :::  \n");
    return 1;
            }

int hrDeviceTable_createEntry_allData(netsnmp_tdata * table_data, struct hrDeviceTable_entry *hrDeviceE)
{
        int i = 0;
        SNMP_DEBUGPRINT("\n hrStorageTable_createEntry_allData ::Start \n");
        struct hrDeviceTable_entry *entry;
        netsnmp_tdata_row *row;
        //entry = SNMP_MALLOC_TYPEDEF(struct hrDeviceTable_entry);
        rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(struct hrDeviceTable_entry), (void**)&entry);
        if (!entry)
            return 0;

        row = netsnmp_tdata_create_row();
        if (!row) {
            rmf_osal_memFreeP(RMF_OSAL_MEM_POD, entry);
            //SNMP_FREE(entry);
            return 0;
        }
        row->data = entry;
/*
   * Index values
*/
        entry->hrDeviceIndex = hrDeviceE->hrDeviceIndex;
        entry->hrDeviceIndex_I = hrDeviceE->hrDeviceIndex_I; //same as Index

        entry->hrDeviceType_len = hrDeviceE->hrDeviceType_len;

        vlMemCpy(entry->hrDeviceType, hrDeviceE->hrDeviceType,
                 entry->hrDeviceType_len * sizeof(oid),
                    MAX_IOD_LENGTH * sizeof(oid));
        entry->hrDeviceDescr_len = hrDeviceE->hrDeviceDescr_len ;
        vlMemCpy(entry->hrDeviceDescr, hrDeviceE->hrDeviceDescr,
                 entry->hrDeviceDescr_len,
                    CHRMAX);
        entry->hrDeviceID_len = hrDeviceE->hrDeviceID_len ;
        vlMemCpy(entry->hrDeviceID, hrDeviceE->hrDeviceID,
                 entry->hrDeviceID_len * sizeof(oid),
                 MAX_IOD_LENGTH * sizeof(oid));
        entry->hrDeviceStatus = hrDeviceE->hrDeviceStatus;
        entry->hrDeviceErrors = hrDeviceE->hrDeviceErrors;

        netsnmp_tdata_row_add_index(row, ASN_UNSIGNED,
                                    &(entry->hrDeviceIndex),
                                    sizeof(entry->hrDeviceIndex));
        netsnmp_tdata_add_row(table_data, row);

        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrDeviceTable_createEntry_allData ::END \n");
        return 1;
}


void
    hrDeviceTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
//     netsnmp_tdata_row *this;
//
//     while ((this = netsnmp_tdata_get_first_row(table))) {
//         netsnmp_tdata_remove_and_delete_row(table, this);
//     }
}

/** handles requests for the hrDeviceTable table */
int
  hrDeviceTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    netsnmp_tdata * vl_table_data; //add
    netsnmp_tdata_row *vl_row;  //add
    vl_row = NULL; //add
    struct hrDeviceTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            //table_entry = (struct hrDeviceTable_entry *)                netsnmp_tdata_extract_entry(request);
            /*changed due to wrong values in retriving first element of the Table*/
            VL_SNMP_PREPARE_AND_CHECK_TABLE_GET_REQUEST(hrDeviceTable_entry);

            switch (table_info->colnum) {
            case COLUMN_HRDEVICEINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrDeviceIndex);
                break;
            case COLUMN_HRDEVICETYPE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->
                                         hrDeviceType,
                                         table_entry->hrDeviceType_len* sizeof(oid));
                break;
            case COLUMN_HRDEVICEDESCR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrDeviceDescr,
                                         table_entry->hrDeviceDescr_len);
                break;
            case COLUMN_HRDEVICEID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->
                                         hrDeviceID,
                                         table_entry->hrDeviceID_len* sizeof(oid));
                break;
            case COLUMN_HRDEVICESTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrDeviceStatus);
                break;
            case COLUMN_HRDEVICEERRORS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_COUNTER,
                                           table_entry->hrDeviceErrors);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}


/** Initialize the hrProcessorTable table by defining its contents and how it's structured */
void
                initialize_table_hrProcessorTable(void) {
    static oid      hrProcessorTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 3};
    size_t          hrProcessorTable_oid_len =
        OID_LENGTH(hrProcessorTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrProcessorTable",
                                            hrProcessorTable_handler,
                                            hrProcessorTable_oid,
                                            hrProcessorTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrProcessorTable", 0);
    //table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(netsnmp_table_registration_info), (void**)&table_info);    
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
                                     0);

    table_info->min_column = COLUMN_HRPROCESSORFRWID;
    table_info->max_column = COLUMN_HRPROCESSORLOAD;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRPROCESSORTABLE_TIMEOUT,
                                 hrProcessorTable_load,
                                 hrProcessorTable_free,
                                 hrProcessorTable_oid,
                                 hrProcessorTable_oid_len);
    cache->magic = (void *) table_data;
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET |                NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | NETSNMP_CACHE_DONT_FREE_EXPIRED | NETSNMP_CACHE_DONT_AUTO_RELEASE;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_get(cache),
                                  "hrProcessorTable");

        /*
         * Initialise the contents of the table here
         */
    if(0 == hrProcessorTable_load(cache,table_data))
    {
        //snmpTargetParamsTable_load"
        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n ERROR:: hrProcessorTable_load Not yet table initialise here \n");
    }
}

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrProcessorTable_createEntry(netsnmp_tdata * table_data,
                                                long hrDeviceIndex) {
    struct hrProcessorTable_entry *entry;
    netsnmp_tdata_row *row;

    //entry = SNMP_MALLOC_TYPEDEF(struct hrProcessorTable_entry);
    rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(struct hrProcessorTable_entry), (void**)&entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        //SNMP_FREE(entry);
        rmf_osal_memFreeP(RMF_OSAL_MEM_POD, entry);
        return NULL;
    }
    row->data = entry;
    entry->hrDeviceIndex = hrDeviceIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrDeviceIndex),
                                sizeof(entry->hrDeviceIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void
    hrProcessorTable_removeEntry(netsnmp_tdata * table_data,
                                 netsnmp_tdata_row * row) {
    struct hrProcessorTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrProcessorTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        //SNMP_FREE(entry);       /* XXX - release any other internal resources */
        rmf_osal_memFreeP(RMF_OSAL_MEM_POD, entry);
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
    hrProcessorTable_load(netsnmp_cache * cache, void *vmagic) {
    return 1;
}

int hrProcessorTable_createEntry_allData(netsnmp_tdata * table_data, struct hrProcessorTable_entry *hrProcessE)
    {
        int i = 0;
        SNMP_DEBUGPRINT("\n hrProcessorTable_createEntry_allData ::Start \n");
        struct hrProcessorTable_entry *entry;
        netsnmp_tdata_row *row;
        //entry = SNMP_MALLOC_TYPEDEF(struct hrProcessorTable_entry);
        rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(struct hrProcessorTable_entry), (void**)&entry);
        if (!entry)
            return 0;

        row = netsnmp_tdata_create_row();
        if (!row) {
            //SNMP_FREE(entry);
            rmf_osal_memFreeP(RMF_OSAL_MEM_POD, entry);
            return 0;
        }
        row->data = entry;
/*
        * Index values
*/
        entry->hrDeviceIndex = hrProcessE->hrDeviceIndex;

        entry->hrProcessorFrwID_len = hrProcessE->hrProcessorFrwID_len;
        vlMemCpy(entry->hrProcessorFrwID, hrProcessE->hrProcessorFrwID,
                 entry->hrProcessorFrwID_len * sizeof(oid),
                 API_MAX_IOD_LENGTH * sizeof(oid));
        entry->hrProcessorLoad = hrProcessE->hrProcessorLoad;

        netsnmp_tdata_row_add_index(row, ASN_UNSIGNED,
                                    &(entry->hrDeviceIndex),
                                    sizeof(entry->hrDeviceIndex));
        netsnmp_tdata_add_row(table_data, row);

        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrProcessorTable_createEntry_allData ::END \n");
        return 1;
}

void
    hrProcessorTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
//     netsnmp_tdata_row *this;
//
//     while ((this = netsnmp_tdata_get_first_row(table))) {
//         netsnmp_tdata_remove_and_delete_row(table, this);
//     }
}

/** handles requests for the hrProcessorTable table */
int
   hrProcessorTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    netsnmp_tdata * vl_table_data; //add
    netsnmp_tdata_row *vl_row;  //add
    vl_row = NULL; //add
    struct hrProcessorTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            //table_entry = (struct hrProcessorTable_entry *)                netsnmp_tdata_extract_entry(request);
            /*changed due to wrong values in retriving first element of the Table*/
            VL_SNMP_PREPARE_AND_CHECK_TABLE_GET_REQUEST(hrProcessorTable_entry);

            switch (table_info->colnum) {
            case COLUMN_HRPROCESSORFRWID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->
                                         hrProcessorFrwID,
                                         table_entry->                                        hrProcessorFrwID_len* sizeof(oid));
                break;
            case COLUMN_HRPROCESSORLOAD:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrProcessorLoad);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the hrSWRunTable table by defining its contents and how it's structured */
void initialize_table_hrSWRunTable(void)
   {
    static oid      hrSWRunTable_oid[] = {  1, 3, 6, 1, 2, 1, 25, 4, 2};
    size_t          hrSWRunTable_oid_len = OID_LENGTH(hrSWRunTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info = NULL;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrSWRunTable",
                                            hrSWRunTable_handler,
                                            hrSWRunTable_oid,
                                            hrSWRunTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_data = netsnmp_tdata_create_table("hrSWRunTable", 0);
    //table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(netsnmp_table_registration_info), (void**)&table_info);

    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrSWRunIndex */
                                     0);

    table_info->min_column = COLUMN_HRSWRUNINDEX;
    table_info->max_column = COLUMN_HRSWRUNSTATUS;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRSWRUNTABLE_TIMEOUT,
                                 hrSWRunTable_load, hrSWRunTable_free,
                                 hrSWRunTable_oid, hrSWRunTable_oid_len);
    cache->magic = (void *) table_data;
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET |
                NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | NETSNMP_CACHE_DONT_FREE_EXPIRED |
                NETSNMP_CACHE_DONT_AUTO_RELEASE;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_get(cache),
                                  "hrSWRunTable");

        /*
         * Initialise the contents of the table here
         */
    if(0 == hrSWRunTable_load(cache,table_data))
    {
        //snmpTargetParamsTable_load"
        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", " ERROR:: hrSWRunTable_load Not yet table initialise here \n");
    }
}
/*
 * Example cache handling - set up table_data list from a suitable file
 */
struct hrSWRunTable_entry  hrSWRunE[2];
int hrSWRunTable_load(netsnmp_cache * cache, void *vmagic) {

    netsnmp_tdata * table_data = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;

    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrSWRunTable_load :: Start  \n");
    bool replace_table = false;
    int count = 0;
    if( netsnmp_tdata_row_first(table_data))
    {
        replace_table = true;
    }
    apioid Vividlogi_EnterprisesOID[10] =
    { 1, 3, 6, 1, 4, 1, 31800, 1, 1, 1 }; // VIVIDLOGIC Enterprises OID

    /**Dummy Data dec . taking 1times**/

    hrSWRunE[0].hrSWRunIndex = 1012;
    hrSWRunE[0].hrSWRunIndex_I = 1012; //same as Index
    string strRunName = "VividLogic Inc., Rev: 1.0.1, tru2way runtime";
    hrSWRunE[0].hrSWRunName_len = strRunName.size();
    vlMemCpy(hrSWRunE[0].hrSWRunName, strRunName.c_str(), hrSWRunE[0].hrSWRunName_len, API_CHRMAX);

    hrSWRunE[0].hrSWRunID_len = (sizeof(Vividlogi_EnterprisesOID)/sizeof(apioid))*sizeof(apioid);
    vlMemCpy(hrSWRunE[0].hrSWRunID, Vividlogi_EnterprisesOID,
             hrSWRunE[0].hrSWRunID_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));

    string strRunPath =getenv("PFC_ROOT");
	
    strRunPath += "/bin/boot";
    hrSWRunE[0].hrSWRunPath_len = strRunPath.size();
    vlMemCpy(hrSWRunE[0].hrSWRunPath, strRunPath.c_str(), hrSWRunE[0].hrSWRunPath_len, API_CHRMAX);

    CMpersistentConfig pfcRc((CMpersistentConfig::CONFIG_TYPE)-1, NULL, NULL);
    strncpy(hrSWRunE[0].hrSWRunParameters, pfcRc.get_actual_path_name(), API_CHRMAX);
    hrSWRunE[0].hrSWRunParameters[API_CHRMAX - 1] = 0;

    hrSWRunE[0].hrSWRunParameters_len = strlen(hrSWRunE[0].hrSWRunParameters);
    hrSWRunE[0].hrSWRunType = HRSWRUNTYPE_APPLICATION;
    hrSWRunE[0].hrSWRunStatus = HRSWRUNSTATUS_RUNNABLE;
    hrSWRunE[0].old_hrSWRunStatus = HRSWRUNSTATUS_RUNNABLE;

    /** Dummy Data Ends............made a dynamic call to get real values**/
    int Maxsize =1;
    for( int nsizelist = 0; nsizelist < Maxsize; nsizelist++)
    {
        if(replace_table)
        {
            replace_table = false;
            Table_free(table_data);

        }
        hrSWRunTable_createEntry_allData(table_data, &hrSWRunE[nsizelist]);
    }

#if 0
    if(Maxsize == 0)
    {
        Table_free(table_data);
        struct hrSWRunTable_entry  hrSWRunE;
        memset(&hrSWRunE, 0, sizeof(struct hrSWRunTable_entry));
        hrSWRunTable_createEntry_allData(table_data, &hrSWRunE);
    }
#endif
    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrSWRunTable_load:: End   :::  \n");
    return 1;
}

int hrSWRunTable_createEntry_allData(netsnmp_tdata * table_data, struct hrSWRunTable_entry *hrSWRunE)
{
    int i = 0;
    SNMP_DEBUGPRINT("\n hrSWRunTable_createEntry_allData ::Start \n");
    struct hrSWRunTable_entry *entry;
    netsnmp_tdata_row *row;
    rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(struct hrSWRunTable_entry), (void**)&entry);
    //entry = SNMP_MALLOC_TYPEDEF(struct hrSWRunTable_entry);
    if (!entry)
        return 0;

    row = netsnmp_tdata_create_row();
    if (!row) {
        //SNMP_FREE(entry);
        rmf_osal_memFreeP(RMF_OSAL_MEM_POD, entry);
        return 0;
    }
    row->data = entry;
    /*
    * Index values
    */
    entry->hrSWRunIndex = hrSWRunE->hrSWRunIndex;
    entry->hrSWRunIndex_I =hrSWRunE->hrSWRunIndex_I; //same as Index
    entry->hrSWRunName_len = hrSWRunE->hrSWRunName_len;
    vlMemCpy(entry->hrSWRunName, hrSWRunE->hrSWRunName, entry->hrSWRunName_len, API_CHRMAX);

    entry->hrSWRunID_len = hrSWRunE->hrSWRunID_len;
    vlMemCpy(entry->hrSWRunID,hrSWRunE->hrSWRunID,
             entry->hrSWRunID_len * sizeof(oid),
             API_MAX_IOD_LENGTH * sizeof(oid));
    entry->hrSWRunPath_len = hrSWRunE->hrSWRunPath_len;
    vlMemCpy(entry->hrSWRunPath, hrSWRunE->hrSWRunPath, entry->hrSWRunPath_len, API_CHRMAX);

    entry->hrSWRunParameters_len = hrSWRunE->hrSWRunParameters_len;
    vlMemCpy(entry->hrSWRunParameters, hrSWRunE->hrSWRunParameters, entry->hrSWRunParameters_len, API_CHRMAX);
    entry->hrSWRunType = hrSWRunE->hrSWRunType;
    entry->hrSWRunStatus =  hrSWRunE->hrSWRunStatus;
    entry->old_hrSWRunStatus = hrSWRunE->old_hrSWRunStatus;
    netsnmp_tdata_row_add_index(row, ASN_UNSIGNED,
                                &(entry->hrSWRunIndex),
                                sizeof(entry->hrSWRunIndex));
    netsnmp_tdata_add_row(table_data, row);

    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrSWRunTable_createEntry_allData ::END \n");
    return 1;
}
void hrSWRunTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
//     netsnmp_tdata_row *this;
//
//     while ((this = netsnmp_tdata_get_first_row(table))) {
//         netsnmp_tdata_remove_and_delete_row(table, this);
//     }
}

/** handles requests for the hrSWRunTable table */
int
    hrSWRunTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    netsnmp_tdata * vl_table_data; //add
    netsnmp_tdata_row *vl_row;  //add
    vl_row = NULL; //add
    struct hrSWRunTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            //table_entry = (struct hrSWRunTable_entry *)                netsnmp_tdata_extract_entry(request);
            /*changed due to wrong values in retriving first element of the Table*/
            VL_SNMP_PREPARE_AND_CHECK_TABLE_GET_REQUEST(hrSWRunTable_entry);

            switch (table_info->colnum) {
            case COLUMN_HRSWRUNINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrSWRunIndex);
                break;
            case COLUMN_HRSWRUNNAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrSWRunName,
                                         table_entry->hrSWRunName_len);
                break;
            case COLUMN_HRSWRUNID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->hrSWRunID,
                                         table_entry->hrSWRunID_len);
                break;
            case COLUMN_HRSWRUNPATH:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrSWRunPath,
                                         table_entry->hrSWRunPath_len);
                break;
            case COLUMN_HRSWRUNPARAMETERS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrSWRunParameters,
                                         table_entry->
                                         hrSWRunParameters_len);
                break;
            case COLUMN_HRSWRUNTYPE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrSWRunType);
                break;
            case COLUMN_HRSWRUNSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrSWRunStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRSWRUNSTATUS:
                /*
                 * or possibly 'netsnmp_check_vb_int_range'
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrSWRunTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRSWRUNSTATUS:
                table_entry->old_hrSWRunStatus =
                    table_entry->hrSWRunStatus;
                table_entry->hrSWRunStatus =
                    *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrSWRunTable_entry *)
                netsnmp_tdata_extract_entry(request);
            netsnmp_tdata_extract_row(request);
            netsnmp_tdata_extract_table(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRSWRUNSTATUS:
                table_entry->hrSWRunStatus =
                    table_entry->old_hrSWRunStatus;
                table_entry->old_hrSWRunStatus = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the hrSWRunPerfTable table by defining its contents and how it's structured */
void initialize_table_hrSWRunPerfTable(void) {
    static oid      hrSWRunPerfTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 5, 1};
    size_t          hrSWRunPerfTable_oid_len =
        OID_LENGTH(hrSWRunPerfTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrSWRunPerfTable",
                                            hrSWRunPerfTable_handler,
                                            hrSWRunPerfTable_oid,
                                            hrSWRunPerfTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrSWRunPerfTable", 0);
   // table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
   rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(netsnmp_table_registration_info), (void**)&table_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrSWRunIndex */
                                     0);

    table_info->min_column = COLUMN_HRSWRUNPERFCPU;
    table_info->max_column = COLUMN_HRSWRUNPERFMEM;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRSWRUNPERFTABLE_TIMEOUT,
                                 hrSWRunPerfTable_load,
                                 hrSWRunPerfTable_free,
                                 hrSWRunPerfTable_oid,
                                 hrSWRunPerfTable_oid_len);
    cache->magic = (void *) table_data;
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET |
            NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | NETSNMP_CACHE_DONT_FREE_EXPIRED |
            NETSNMP_CACHE_DONT_AUTO_RELEASE;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_get(cache),
                                  "hrSWRunPerfTable");

        /*
         * Initialise the contents of the table here
         */
    if(0 == hrSWRunTable_load(cache,table_data))
    {
        //snmpTargetParamsTable_load"
        RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", " ERROR:: hrSWRunTable_load Not yet table initialise here \n");
    }
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int hrSWRunPerfTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table_data = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;

    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrSWRunPerfTable_load :: Start  \n");
    bool replace_table = false;
    int count = 0;
    if( netsnmp_tdata_row_first(table_data))
    {
        replace_table = true;
    }

    /**Dummy Data dec . taking 2times**/

    struct hrSWRunPerfTable_entry  hrSWRunPerfE[2];
    hrSWRunPerfE[0].hrSWRunIndex = hrSWRunE[0].hrSWRunIndex; //Index of hrSWRunTbale
    hrSWRunPerfE[0].hrSWRunPerfCPU = 4427;
    hrSWRunPerfE[0].hrSWRunPerfMem = 34860;

    /** Dummy Data Ends............made a dynamic call to get real values**/
    int Maxsize =1;
    for( int nsizelist = 0; nsizelist < Maxsize; nsizelist++)
    {
        if(replace_table)
        {
            replace_table = false;
            Table_free(table_data);

        }
        hrSWRunPerfTable_createEntry_allData(table_data, &hrSWRunPerfE[nsizelist]);
    }
#if 0
    if(Maxsize == 0)
    {
        Table_free(table_data);
        struct hrSWRunPerfTable_entry  hrSWRunPerfE;
        memset(&hrSWRunPerfE, 0, sizeof(struct hrSWRunPerfTable_entry));
        hrSWRunPerfTable_createEntry_allData(table_data, &hrSWRunPerfE);
    }
#endif
    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrSWRunPerfTable_load:: End   :::  \n");
    return 1;
}

int hrSWRunPerfTable_createEntry_allData(netsnmp_tdata * table_data, struct hrSWRunPerfTable_entry *hrSWRunPerfE)
{
    int i = 0;
    SNMP_DEBUGPRINT("\n hrSWRunPerfTable_createEntry_allData ::Start \n");
    struct hrSWRunPerfTable_entry *entry;
    netsnmp_tdata_row *row;
    //entry = SNMP_MALLOC_TYPEDEF(struct hrSWRunPerfTable_entry);
    rmf_osal_memAllocP(RMF_OSAL_MEM_POD, sizeof(struct hrSWRunPerfTable_entry), (void**)&entry);
    if (!entry)
        return 0;

    row = netsnmp_tdata_create_row();
    if (!row) {
        //SNMP_FREE(entry);
        rmf_osal_memFreeP(RMF_OSAL_MEM_POD, entry);
        return 0;
    }
    row->data = entry;
    /*
    * Index values
    */
    entry->hrSWRunIndex = hrSWRunPerfE->hrSWRunIndex; //Index of hrSWRunTbale
    entry->hrSWRunPerfCPU = hrSWRunPerfE->hrSWRunPerfCPU;
    entry->hrSWRunPerfMem = hrSWRunPerfE->hrSWRunPerfMem;
    netsnmp_tdata_row_add_index(row, ASN_UNSIGNED,
                                &(entry->hrSWRunIndex),
                                sizeof(entry->hrSWRunIndex));
    netsnmp_tdata_add_row(table_data, row);

    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n hrSWRunPerfTable_createEntry_allData ::END \n");
    return 1;
}

void  hrSWRunPerfTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
//    netsnmp_tdata_row *this;

//     while ((this = netsnmp_tdata_get_first_row(table))) {
//         netsnmp_tdata_remove_and_delete_row(table, this);
//     }
}

/** handles requests for the hrSWRunPerfTable table */
int
   hrSWRunPerfTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    netsnmp_tdata * vl_table_data; //add
    netsnmp_tdata_row *vl_row;  //add
    vl_row = NULL; //add
    struct hrSWRunPerfTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
           // table_entry = (struct hrSWRunPerfTable_entry *)                netsnmp_tdata_extract_entry(request);
            /*changed due to wrong values in retriving first element of the Table*/
            VL_SNMP_PREPARE_AND_CHECK_TABLE_GET_REQUEST(hrSWRunPerfTable_entry);

            switch (table_info->colnum) {
            case COLUMN_HRSWRUNPERFCPU:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrSWRunPerfCPU);
                break;
            case COLUMN_HRSWRUNPERFMEM:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrSWRunPerfMem);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}



#if 0  //May be later this below tables can be added

/** Initialize the hrNetworkTable table by defining its contents and how it's structured */
void
                initialize_table_hrNetworkTable(void) {
    static oid      hrNetworkTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 4};
    size_t          hrNetworkTable_oid_len =
        OID_LENGTH(hrNetworkTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrNetworkTable",
                                            hrNetworkTable_handler,
                                            hrNetworkTable_oid,
                                            hrNetworkTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrNetworkTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
                                     0);

    table_info->min_column = COLUMN_HRNETWORKIFINDEX;
    table_info->max_column = COLUMN_HRNETWORKIFINDEX;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRNETWORKTABLE_TIMEOUT,
                                 hrNetworkTable_load, hrNetworkTable_free,
                                 hrNetworkTable_oid,
                                 hrNetworkTable_oid_len), cache->magic =
        (void *) table_data;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_GET(cache),
                                  TABLE_DATA_NAME))

        /*
         * Initialise the contents of the table here
         */
}

    /*
     * Typical data structure for a row entry
     */
struct hrNetworkTable_entry {
    /*
     * Index values
     */
    long            hrDeviceIndex;

    /*
     * Column values
     */
    long            hrNetworkIfIndex;

    int             valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrNetworkTable_createEntry(netsnmp_tdata * table_data,
                                              long hrDeviceIndex) {
    struct hrNetworkTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct hrNetworkTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;
    entry->hrDeviceIndex = hrDeviceIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrDeviceIndex),
                                sizeof(entry->hrDeviceIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void
    hrNetworkTable_removeEntry(netsnmp_tdata * table_data,
                               netsnmp_tdata_row * row) {
    struct hrNetworkTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrNetworkTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
                hrNetworkTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;
    FILE *          fp;
    char            buf[STRMAX];
    ;

    fp = fopen("/data/for/hrNetworkTable", "r");
    while (fgets(buf, STRMAX, fp)) {
        /*
         * Unpick 'buf' to extract the index values...
         */
        this = hrNetworkTable_createEntry(table, hrDeviceIndex);
        /*
         * ... and then populate 'this' with the column values
         */
    }
    fclose(fp);
}

int
                hrNetworkTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the hrNetworkTable table */
int
   hrNetworkTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    struct hrNetworkTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrNetworkTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRNETWORKIFINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrNetworkIfIndex);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

# Determine the first/last column names

/** Initialize the hrPrinterTable table by defining its contents and how it's structured */
void
                initialize_table_hrPrinterTable(void) {
    static oid      hrPrinterTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 5};
    size_t          hrPrinterTable_oid_len =
        OID_LENGTH(hrPrinterTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrPrinterTable",
                                            hrPrinterTable_handler,
                                            hrPrinterTable_oid,
                                            hrPrinterTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrPrinterTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
                                     0);

    table_info->min_column = COLUMN_HRPRINTERSTATUS;
    table_info->max_column = COLUMN_HRPRINTERDETECTEDERRORSTATE;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRPRINTERTABLE_TIMEOUT,
                                 hrPrinterTable_load, hrPrinterTable_free,
                                 hrPrinterTable_oid,
                                 hrPrinterTable_oid_len), cache->magic =
        (void *) table_data;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_GET(cache),
                                  TABLE_DATA_NAME))

        /*
         * Initialise the contents of the table here
         */
}

    /*
     * Typical data structure for a row entry
     */
struct hrPrinterTable_entry {
    /*
     * Index values
     */
    long            hrDeviceIndex;

    /*
     * Column values
     */
    long            hrPrinterStatus;
    char            hrPrinterDetectedErrorState[NNN];
    size_t          hrPrinterDetectedErrorState_len;

    int             valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrPrinterTable_createEntry(netsnmp_tdata * table_data,
                                              long hrDeviceIndex) {
    struct hrPrinterTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct hrPrinterTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;
    entry->hrDeviceIndex = hrDeviceIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrDeviceIndex),
                                sizeof(entry->hrDeviceIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void

    hrPrinterTable_removeEntry(netsnmp_tdata * table_data,
                               netsnmp_tdata_row * row) {
    struct hrPrinterTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrPrinterTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
                hrPrinterTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;
    FILE *          fp;
    char            buf[STRMAX];
    ;

    fp = fopen("/data/for/hrPrinterTable", "r");
    while (fgets(buf, STRMAX, fp)) {
        /*
         * Unpick 'buf' to extract the index values...
         */
        this = hrPrinterTable_createEntry(table, hrDeviceIndex);
        /*
         * ... and then populate 'this' with the column values
         */
    }
    fclose(fp);
}

int
                hrPrinterTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the hrPrinterTable table */
int
    hrPrinterTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    struct hrPrinterTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrPrinterTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRPRINTERSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrPrinterStatus);
                break;
            case COLUMN_HRPRINTERDETECTEDERRORSTATE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrPrinterDetectedErrorState,
                                         table_entry->
                                         hrPrinterDetectedErrorState_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

# Determine the first/last column names

/** Initialize the hrDiskStorageTable table by defining its contents and how it's structured */
void
                initialize_table_hrDiskStorageTable(void) {
    static oid      hrDiskStorageTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 6};
    size_t          hrDiskStorageTable_oid_len =
        OID_LENGTH(hrDiskStorageTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrDiskStorageTable",
                                            hrDiskStorageTable_handler,
                                            hrDiskStorageTable_oid,
                                            hrDiskStorageTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrDiskStorageTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
                                     0);

    table_info->min_column = COLUMN_HRDISKSTORAGEACCESS;
    table_info->max_column = COLUMN_HRDISKSTORAGECAPACITY;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRDISKSTORAGETABLE_TIMEOUT,
                                 hrDiskStorageTable_load,
                                 hrDiskStorageTable_free,
                                 hrDiskStorageTable_oid,
                                 hrDiskStorageTable_oid_len),
        cache->magic = (void *) table_data;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_GET(cache),
                                  TABLE_DATA_NAME))

        /*
         * Initialise the contents of the table here
         */
}

    /*
     * Typical data structure for a row entry
     */
struct hrDiskStorageTable_entry {
    /*
     * Index values
     */
    long            hrDeviceIndex;

    /*
     * Column values
     */
    long            hrDiskStorageAccess;
    long            hrDiskStorageMedia;
    long            hrDiskStorageRemoveble;
    long            hrDiskStorageCapacity;

    int             valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrDiskStorageTable_createEntry(netsnmp_tdata *
                                                  table_data,
                                                  long hrDeviceIndex) {
    struct hrDiskStorageTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct hrDiskStorageTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;
    entry->hrDeviceIndex = hrDeviceIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrDeviceIndex),
                                sizeof(entry->hrDeviceIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void
    hrDiskStorageTable_removeEntry(netsnmp_tdata * table_data,
                                   netsnmp_tdata_row * row) {
    struct hrDiskStorageTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrDiskStorageTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
  hrDiskStorageTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;
    FILE *          fp;
    char            buf[STRMAX];
    ;

    fp = fopen("/data/for/hrDiskStorageTable", "r");
    while (fgets(buf, STRMAX, fp)) {
        /*
         * Unpick 'buf' to extract the index values...
         */
        this = hrDiskStorageTable_createEntry(table, hrDeviceIndex);
        /*
         * ... and then populate 'this' with the column values
         */
    }
    fclose(fp);
}

int
    hrDiskStorageTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the hrDiskStorageTable table */
int
    hrDiskStorageTable_handler(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    struct hrDiskStorageTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrDiskStorageTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRDISKSTORAGEACCESS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrDiskStorageAccess);
                break;
            case COLUMN_HRDISKSTORAGEMEDIA:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrDiskStorageMedia);
                break;
            case COLUMN_HRDISKSTORAGEREMOVEBLE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrDiskStorageRemoveble);
                break;
            case COLUMN_HRDISKSTORAGECAPACITY:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrDiskStorageCapacity);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

# Determine the first/last column names

/** Initialize the hrPartitionTable table by defining its contents and how it's structured */
void
                initialize_table_hrPartitionTable(void) {
    static oid      hrPartitionTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 7};
    size_t          hrPartitionTable_oid_len =
        OID_LENGTH(hrPartitionTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrPartitionTable",
                                            hrPartitionTable_handler,
                                            hrPartitionTable_oid,
                                            hrPartitionTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrPartitionTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
                                     ASN_INTEGER,       /* index: hrPartitionIndex */
                                     0);

    table_info->min_column = COLUMN_HRPARTITIONINDEX;
    table_info->max_column = COLUMN_HRPARTITIONFSINDEX;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRPARTITIONTABLE_TIMEOUT,
                                 hrPartitionTable_load,
                                 hrPartitionTable_free,
                                 hrPartitionTable_oid,
                                 hrPartitionTable_oid_len), cache->magic =
        (void *) table_data;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_GET(cache),
                                  TABLE_DATA_NAME))

        /*
         * Initialise the contents of the table here
         */
}

    /*
     * Typical data structure for a row entry
     */
struct hrPartitionTable_entry {
    /*
     * Index values
     */
    long            hrDeviceIndex;
    long            hrPartitionIndex;

    /*
     * Column values
     */
    long            hrPartitionIndex;
    char            hrPartitionLabel[NNN];
    size_t          hrPartitionLabel_len;
    char            hrPartitionID[NNN];
    size_t          hrPartitionID_len;
    long            hrPartitionSize;
    long            hrPartitionFSIndex;

    int             valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrPartitionTable_createEntry(netsnmp_tdata * table_data,
                                                long hrDeviceIndex,
                                                long hrPartitionIndex) {
    struct hrPartitionTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct hrPartitionTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;
    entry->hrDeviceIndex = hrDeviceIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrDeviceIndex),
                                sizeof(entry->hrDeviceIndex));
    entry->hrPartitionIndex = hrPartitionIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrPartitionIndex),
                                sizeof(entry->hrPartitionIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void
 hrPartitionTable_removeEntry(netsnmp_tdata * table_data,
                                 netsnmp_tdata_row * row) {
    struct hrPartitionTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrPartitionTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
                hrPartitionTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;
    FILE *          fp;
    char            buf[STRMAX];
    ;

    fp = fopen("/data/for/hrPartitionTable", "r");
    while (fgets(buf, STRMAX, fp)) {
        /*
         * Unpick 'buf' to extract the index values...
         */
        this =
            hrPartitionTable_createEntry(table, hrDeviceIndex,
                                         hrPartitionIndex);
        /*
         * ... and then populate 'this' with the column values
         */
    }
    fclose(fp);
}

int
                hrPartitionTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the hrPartitionTable table */
int

    hrPartitionTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    struct hrPartitionTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrPartitionTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRPARTITIONINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrPartitionIndex);
                break;
            case COLUMN_HRPARTITIONLABEL:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrPartitionLabel,
                                         table_entry->
                                         hrPartitionLabel_len);
                break;
            case COLUMN_HRPARTITIONID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrPartitionID,
                                         table_entry->hrPartitionID_len);
                break;
            case COLUMN_HRPARTITIONSIZE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrPartitionSize);
                break;
            case COLUMN_HRPARTITIONFSINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrPartitionFSIndex);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

# Determine the first/last column names

/** Initialize the hrFSTable table by defining its contents and how it's structured */
void
                initialize_table_hrFSTable(void) {
    static oid      hrFSTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 3, 8};
    size_t          hrFSTable_oid_len = OID_LENGTH(hrFSTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrFSTable", hrFSTable_handler,
                                            hrFSTable_oid,
                                            hrFSTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_data = netsnmp_tdata_create_table("hrFSTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrFSIndex */
                                     0);

    table_info->min_column = COLUMN_HRFSINDEX;
    table_info->max_column = COLUMN_HRFSLASTPARTIALBACKUPDATE;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRFSTABLE_TIMEOUT,
                                 hrFSTable_load, hrFSTable_free,
                                 hrFSTable_oid, hrFSTable_oid_len),
        cache->magic = (void *) table_data;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_GET(cache),
                                  TABLE_DATA_NAME))

        /*
         * Initialise the contents of the table here
         */
}

    /*
     * Typical data structure for a row entry
     */
struct hrFSTable_entry {
    /*
     * Index values
     */
    long            hrFSIndex;

    /*
     * Column values
     */
    long            hrFSIndex;
    char            hrFSMountPoint[NNN];
    size_t          hrFSMountPoint_len;
    char            hrFSRemoteMountPoint[NNN];
    size_t          hrFSRemoteMountPoint_len;
    oid             hrFSType[NNN];
    size_t          hrFSType_len;
    long            hrFSAccess;
    long            hrFSBootable;
    long            hrFSStorageIndex;
    char            hrFSLastFullBackupDate[NNN];
    size_t          hrFSLastFullBackupDate_len;
    char            old_hrFSLastFullBackupDate[NNN];
    size_t          old_hrFSLastFullBackupDate_len;
    char            hrFSLastPartialBackupDate[NNN];
    size_t          hrFSLastPartialBackupDate_len;
    char            old_hrFSLastPartialBackupDate[NNN];
    size_t          old_hrFSLastPartialBackupDate_len;

    int             valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrFSTable_createEntry(netsnmp_tdata * table_data,
                                         long hrFSIndex) {
    struct hrFSTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct hrFSTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;
    entry->hrFSIndex = hrFSIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrFSIndex),
                                sizeof(entry->hrFSIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void
    hrFSTable_removeEntry(netsnmp_tdata * table_data,
                          netsnmp_tdata_row * row) {
    struct hrFSTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrFSTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int
                hrFSTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;
    FILE *          fp;
    char            buf[STRMAX];
    ;

    fp = fopen("/data/for/hrFSTable", "r");
    while (fgets(buf, STRMAX, fp)) {
        /*
         * Unpick 'buf' to extract the index values...
         */
        this = hrFSTable_createEntry(table, hrFSIndex);
        /*
         * ... and then populate 'this' with the column values
         */
    }
    fclose(fp);
}

int
                hrFSTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the hrFSTable table */
int
    hrFSTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    struct hrFSTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrFSTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRFSINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrFSIndex);
                break;
            case COLUMN_HRFSMOUNTPOINT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrFSMountPoint,
                                         table_entry->hrFSMountPoint_len);
                break;
            case COLUMN_HRFSREMOTEMOUNTPOINT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrFSRemoteMountPoint,
                                         table_entry->
                                         hrFSRemoteMountPoint_len);
                break;
            case COLUMN_HRFSTYPE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->hrFSType,
                                         table_entry->hrFSType_len);
                break;
            case COLUMN_HRFSACCESS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrFSAccess);
                break;
            case COLUMN_HRFSBOOTABLE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrFSBootable);
                break;
            case COLUMN_HRFSSTORAGEINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrFSStorageIndex);
                break;
            case COLUMN_HRFSLASTFULLBACKUPDATE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrFSLastFullBackupDate,
                                         table_entry->
                                         hrFSLastFullBackupDate_len);
                break;
            case COLUMN_HRFSLASTPARTIALBACKUPDATE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrFSLastPartialBackupDate,
                                         table_entry->
                                         hrFSLastPartialBackupDate_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrFSTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRFSLASTFULLBACKUPDATE:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size'
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              hrFSLastFullBackupDate));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_HRFSLASTPARTIALBACKUPDATE:
                /*
                 * or possiblc 'netsnmp_check_vb_type_and_size'
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              hrFSLastPartialBackupDate));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrFSTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRFSLASTFULLBACKUPDATE:
                memcpy(table_entry->old_hrFSLastFullBackupDate,
                       table_entry->hrFSLastFullBackupDate,
                       sizeof(table_entry->hrFSLastFullBackupDate));
                table_entry->old_hrFSLastFullBackupDate_len =
                    table_entry->hrFSLastFullBackupDate_len;
                memset(table_entry->hrFSLastFullBackupDate, 0,
                       sizeof(table_entry->hrFSLastFullBackupDate));
                memcpy(table_entry->hrFSLastFullBackupDate,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->hrFSLastFullBackupDate_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_HRFSLASTPARTIALBACKUPDATE:
                memcpy(table_entry->old_hrFSLastPartialBackupDate,
                       table_entry->hrFSLastPartialBackupDate,
                       sizeof(table_entry->hrFSLastPartialBackupDate));
                table_entry->old_hrFSLastPartialBackupDate_len =
                    table_entry->hrFSLastPartialBackupDate_len;
                memset(table_entry->hrFSLastPartialBackupDate, 0,
                       sizeof(table_entry->hrFSLastPartialBackupDate));
                memcpy(table_entry->hrFSLastPartialBackupDate,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->hrFSLastPartialBackupDate_len =
                    request->requestvb->val_len;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrFSTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_row = netsnmp_tdata_extract_row(request);
            table_data = netsnmp_tdata_extract_table(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_HRFSLASTFULLBACKUPDATE:
                memcpy(table_entry->hrFSLastFullBackupDate,
                       table_entry->old_hrFSLastFullBackupDate,
                       sizeof(table_entry->hrFSLastFullBackupDate));
                memset(table_entry->old_hrFSLastFullBackupDate, 0,
                       sizeof(table_entry->hrFSLastFullBackupDate));
                table_entry->hrFSLastFullBackupDate_len =
                    table_entry->old_hrFSLastFullBackupDate_len;
                break;
            case COLUMN_HRFSLASTPARTIALBACKUPDATE:
                memcpy(table_entry->hrFSLastPartialBackupDate,
                       table_entry->old_hrFSLastPartialBackupDate,
                       sizeof(table_entry->hrFSLastPartialBackupDate));
                memset(table_entry->old_hrFSLastPartialBackupDate, 0,
                       sizeof(table_entry->hrFSLastPartialBackupDate));
                table_entry->hrFSLastPartialBackupDate_len =
                    table_entry->old_hrFSLastPartialBackupDate_len;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}


# Determine the first/last column names

/** Initialize the hrSWInstalledTable table by defining its contents and how it's structured */
void
                initialize_table_hrSWInstalledTable(void) {
    static oid      hrSWInstalledTable_oid[] = {
    1, 3, 6, 1, 2, 1, 25, 6, 3};
    size_t          hrSWInstalledTable_oid_len =
        OID_LENGTH(hrSWInstalledTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata * table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache * cache;

    reg =
        netsnmp_create_handler_registration("hrSWInstalledTable",
                                            hrSWInstalledTable_handler,
                                            hrSWInstalledTable_oid,
                                            hrSWInstalledTable_oid_len,
                                            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("hrSWInstalledTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrSWInstalledIndex */
                                     0);

    table_info->min_column = COLUMN_HRSWINSTALLEDINDEX;
    table_info->max_column = COLUMN_HRSWINSTALLEDDATE;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(HRSWINSTALLEDTABLE_TIMEOUT,
                                 hrSWInstalledTable_load,
                                 hrSWInstalledTable_free,
                                 hrSWInstalledTable_oid,
                                 hrSWInstalledTable_oid_len),
        cache->magic = (void *) table_data;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_GET(cache),
                                  TABLE_DATA_NAME))

        /*
         * Initialise the contents of the table here
        */
}

    /*
     * Typical data structure for a row entry
    */
struct hrSWInstalledTable_entry {
    /*
     * Index values
    */
    long            hrSWInstalledIndex;

    /*
     * Column values
    */
    long            hrSWInstalledIndex;
    char            hrSWInstalledName[NNN];
    size_t          hrSWInstalledName_len;
    oid             hrSWInstalledID[NNN];
    size_t          hrSWInstalledID_len;
    long            hrSWInstalledType;
    char            hrSWInstalledDate[NNN];
    size_t          hrSWInstalledDate_len;

    int             valid;
};

/*
 * create a new row in the table
 */
netsnmp_tdata_row *hrSWInstalledTable_createEntry(netsnmp_tdata *
                                                  table_data,
                                                  long hrSWInstalledIndex)
{
    struct hrSWInstalledTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct hrSWInstalledTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
}
    row->data = entry;
    entry->hrSWInstalledIndex = hrSWInstalledIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->hrSWInstalledIndex),
                                sizeof(entry->hrSWInstalledIndex));
    netsnmp_tdata_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table
 */
void
    hrSWInstalledTable_removeEntry(netsnmp_tdata * table_data,
                                   netsnmp_tdata_row * row) {
    struct hrSWInstalledTable_entry *entry;

    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct hrSWInstalledTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}

/*
 * Example cache handling - set up table_data list from a suitable file
 */
int






             hrSWInstalledTable_load(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;
    FILE *          fp;
    char            buf[STRMAX];
    ;

    fp = fopen("/data/for/hrSWInstalledTable", "r");
    while (fgets(buf, STRMAX, fp)) {
        /*
         * Unpick 'buf' to extract the index values...
        */
        this = hrSWInstalledTable_createEntry(table, hrSWInstalledIndex);
        /*
         * ... and then populate 'this' with the column values
        */
}
    fclose(fp);
}

int
             hrSWInstalledTable_free(netsnmp_cache * cache, void *vmagic) {
    netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
}
}

/** handles requests for the hrSWInstalledTable table */
int
  hrSWInstalledTable_handler(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests) {

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    struct hrSWInstalledTable_entry *table_entry;
    int             ret;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
        */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct hrSWInstalledTable_entry *)
                netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
    case COLUMN_HRSWINSTALLEDINDEX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
}
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           hrSWInstalledIndex);
                break;
    case COLUMN_HRSWINSTALLEDNAME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
}
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrSWInstalledName,
                                         table_entry->
                                         hrSWInstalledName_len);
                break;
    case COLUMN_HRSWINSTALLEDID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
}
                snmp_set_var_typed_value(request->requestvb, ASN_OBJECT_ID,
                                         (u_char *) table_entry->
                                         hrSWInstalledID,
                                         table_entry->hrSWInstalledID_len);
                break;
    case COLUMN_HRSWINSTALLEDTYPE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
}
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->hrSWInstalledType);
                break;
    case COLUMN_HRSWINSTALLEDDATE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
}
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         hrSWInstalledDate,
                                         table_entry->
                                         hrSWInstalledDate_len);
                break;
    default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
}
}
        break;

}
    return SNMP_ERR_NOERROR;
}

#endif //if 0



