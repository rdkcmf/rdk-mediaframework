/*
* If not stated otherwise in this file or this component's LICENSE file the
* following copyright and licenses apply:
*
* Copyright 2011 RDK Management
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.table_data.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

//time
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "docsDevEventTable.h"
#include "vl_ocStbHost_GetData.h"
#include "docsDevEventTable_enums.h"
#include "docsDevEvControl.h"
#include "SnmpIORM.h"
#include "utilityMacros.h"
#include "persistentconfig.h"
#include "docsDevEvControlTable.h"
#include "vlMutex.h"
#include "Tlvevent.h"
#include "cardManagerIf.h"
#include "rdk_debug.h"
#include "rmf_osal_sync.h"

#if USE_SYSRES_MLT
#include "rpl_new.h"
#endif

static vlMutex & vlg_TlvEventDblock = TlvConfig::vlGetTlvEventDbLock();

#define VL_SNMP_DOCS_EVENT_TABLE_LOG_FILE_NAME      "/etc/docsDevEventTable.log"
#define VL_SNMP_DOCS_EVENT_TABLE_LOCK_NAME          "EdocsDevEventhandling"
static  rmf_osal_MutexClass DocEvtMutex;

typedef struct _VL_SNMP_EVENT_MESSAGE_MAP_ENTRY
{
    int nEventId;
    int nEventLevel;
    const char * pszMessage;

}VL_SNMP_EVENT_MESSAGE_MAP_ENTRY;

static VL_SNMP_EVENT_MESSAGE_MAP_ENTRY TLVEventMess[] =
{
    {ERRORCODE_D01_0, DOCSDEVEVLEVEL_CRITICAL   , "DHCP FAILED - Discover sent, no offer received for %s"},
    {ERRORCODE_D02_0, DOCSDEVEVLEVEL_CRITICAL   , "DHCP FAILED - Request sent, No response for %s"},
    {ERRORCODE_D03_1, DOCSDEVEVLEVEL_CRITICAL   , "DHCP FAILED - Response doesn't contain ALL the valid fields for %s"},

    {ERRORCODE_D12_0, DOCSDEVEVLEVEL_CRITICAL   , "DHCP failed - RS sent, no RA received"},
    {ERRORCODE_D12_1, DOCSDEVEVLEVEL_CRITICAL   , "DHCP Failed - Invalid RA"},
    {ERRORCODE_D12_2, DOCSDEVEVLEVEL_CRITICAL   , "DHCP failed - DHCP Solicit sent, No DHCP Advertise received"},
    {ERRORCODE_D12_3, DOCSDEVEVLEVEL_CRITICAL   , "DHCP failed - DHCP Request sent, No DHCP REPLY received"},

    {ERRORCODE_D13_1, DOCSDEVEVLEVEL_CRITICAL   , "Link-Local address failed DAD"},
    {ERRORCODE_D13_2, DOCSDEVEVLEVEL_CRITICAL   , "DHCP lease address failed DAD"},

    {ERRORCODE_D101_0, DOCSDEVEVLEVEL_ERROR     , "DHCP RENEW sent - No response for %s"},
    {ERRORCODE_D102_0, DOCSDEVEVLEVEL_ERROR     , "DHCP REBIND sent - No response for %s"},
    {ERRORCODE_D103_0, DOCSDEVEVLEVEL_ERROR     , "DHCP RENEW sent - Invalid DHCP option for %s"},
    {ERRORCODE_D104_0, DOCSDEVEVLEVEL_ERROR     , "DHCP REBIND sent - Invalid DHCP option for %s"},

    {ERRORCODE_I401_1, DOCSDEVEVLEVEL_NOTICE    , "Unrecognized TLV or sub-TLVs detected TLV%d"},
    {ERRORCODE_I401_2, DOCSDEVEVLEVEL_NOTICE    , "Invalid TLV Type encoding TLV%d"},
    {ERRORCODE_I401_3, DOCSDEVEVLEVEL_NOTICE    , "Resource limit reached"},
    {ERRORCODE_I401_11,DOCSDEVEVLEVEL_NOTICE    , "TLV-1 - Multiple TLVs not allowed"},

    {ERRORCODE_I411_1, DOCSDEVEVLEVEL_NOTICE    , "TLV-11 - unrecognized OID"},
    {ERRORCODE_I411_2, DOCSDEVEVLEVEL_WARNING   , "TLV-11 - Multiple SET operations of object instance attempted"},
    {ERRORCODE_I411_3, DOCSDEVEVLEVEL_WARNING   , "TLV-11 - Invalid varbind encoding"},

    {ERRORCODE_I438_1, DOCSDEVEVLEVEL_WARNING   , "TLV38 - Duplicate TLV Received"},
    {ERRORCODE_I438_2, DOCSDEVEVLEVEL_CRITICAL  , "TLV38 - No Receiver IP Address received in TLV"},
    {ERRORCODE_I438_3, DOCSDEVEVLEVEL_WARNING   , "TLV38 - No SNMPv2c trap specified"},
    {ERRORCODE_I438_4, DOCSDEVEVLEVEL_WARNING   , "TLV38 - Inconsistent IP address type specified in TLV1"},

    {ERRORCODE_I443_1, DOCSDEVEVLEVEL_CRITICAL  , "TLV43 - Invalid Vendor ID encoding"},

    {ERRORCODE_I453_1, DOCSDEVEVLEVEL_CRITICAL  , "TLV53 - Community Name not present"},
    {ERRORCODE_I453_2, DOCSDEVEVLEVEL_CRITICAL  , "TLV53 - Transport address not present"},
    {ERRORCODE_I453_3, DOCSDEVEVLEVEL_WARNING   , "TLV53 - Multiple sub-TLVs not allowed"},
    {ERRORCODE_I453_4, DOCSDEVEVLEVEL_WARNING   , "TLV53 - SNMP syntax conflicts detected"},
    {ERRORCODE_I453_5, DOCSDEVEVLEVEL_WARNING   , "TLV53 - Insufficient table resources"},
    {ERRORCODE_I453_6, DOCSDEVEVLEVEL_WARNING   , "TLV53 - Attempt to create duplicate entry not allowed"},

    {ERRORCODE_I454_1, DOCSDEVEVLEVEL_WARNING   , "TLV54 - Access View Name not present"},
    {ERRORCODE_I454_2, DOCSDEVEVLEVEL_WARNING   , "TLV54 - Multiple sub-TLVs not allowed"},
    {ERRORCODE_I454_3, DOCSDEVEVLEVEL_WARNING   , "TLV54 - SNMP syntax conflicts detected"},
    {ERRORCODE_I454_4, DOCSDEVEVLEVEL_WARNING   , "TLV54 - Insufficient table resources"},
    {ERRORCODE_I454_5, DOCSDEVEVLEVEL_WARNING   , "TLV54 - Attempt to create duplicate entry not allowed"},

    {ERRORCODE_I4010, DOCSDEVEVLEVEL_NOTICE     , "TLV-11 - unrecognized OID"},
    {ERRORCODE_I4020, DOCSDEVEVLEVEL_WARNING    , "TLV-11 - Illegal Set operation failed"},
    {ERRORCODE_I4030, DOCSDEVEVLEVEL_WARNING    , "TLV-11 - Failed to set duplicate elements"},
    {ERRORCODE_I4040, DOCSDEVEVLEVEL_NOTICE     , "TLV - unrecognized Type"},
    {ERRORCODE_I4050, DOCSDEVEVLEVEL_WARNING    , "TLV - Failed to set duplicate elements"},
    {ERRORCODE_I4060, DOCSDEVEVLEVEL_WARNING    , "TLV - illegal encoding failed"},
    {ERRORCODE_I4070, DOCSDEVEVLEVEL_WARNING    , "TLV - Invalid element multiplicity"},
    {ERRORCODE_I4080, DOCSDEVEVLEVEL_WARNING    , "TLV - Insufficient resources"},
    {ERRORCODE_I4090, DOCSDEVEVLEVEL_WARNING    , "TLV - Element Already exists Failed creation"},

    {ERRORCODE_B01_0 , DOCSDEVEVLEVEL_NOTICE    , "Hardware and OS UP"},
    {ERRORCODE_B02_0 , DOCSDEVEVLEVEL_NOTICE    , "Execution Engine UP"},
    {ERRORCODE_B03_0 , DOCSDEVEVLEVEL_NOTICE    , "Copy Protection Resource opened"},
    {ERRORCODE_B04_0 , DOCSDEVEVLEVEL_NOTICE    , "Host AuthKey sent"},
    {ERRORCODE_B05_0 , DOCSDEVEVLEVEL_CRITICAL  , "Binding Failure: Card reasons"},
    {ERRORCODE_B06_0 , DOCSDEVEVLEVEL_CRITICAL  , "Binding Failure: Invalid Host Cert"},
    {ERRORCODE_B07_0 , DOCSDEVEVLEVEL_CRITICAL  , "Binding Failure: Invalid Host Signature"},
    {ERRORCODE_B08_0 , DOCSDEVEVLEVEL_CRITICAL  , "Binding Failure: Invalid Host AuthKey"},
    {ERRORCODE_B09_0 , DOCSDEVEVLEVEL_CRITICAL  , "Binding Failure: Other"},
    {ERRORCODE_B10_0 , DOCSDEVEVLEVEL_CRITICAL  , "Card Validation Error: Validation revoked"},
    {ERRORCODE_B11_0 , DOCSDEVEVLEVEL_CRITICAL  , "Binding Failure. Incompatible module"},
    {ERRORCODE_B12_0 , DOCSDEVEVLEVEL_NOTICE    , "Binding Complete: Card/Host Validated"},
    {ERRORCODE_B13_0 , DOCSDEVEVLEVEL_NOTICE    , "Copy Protection initiated"},
    {ERRORCODE_B14_0 , DOCSDEVEVLEVEL_NOTICE    , "FDC acquired"},
    {ERRORCODE_B15_0 , DOCSDEVEVLEVEL_NOTICE    , "Set QPSK mode"},
    {ERRORCODE_B16_0 , DOCSDEVEVLEVEL_NOTICE    , "Set Adv. DSG mode"},
    {ERRORCODE_B17_0 , DOCSDEVEVLEVEL_NOTICE    , "Set Adv. Dsg 1-way mode"},
    {ERRORCODE_B18_0 , DOCSDEVEVLEVEL_NOTICE    , "DSG acquired"},
    {ERRORCODE_B19_0 , DOCSDEVEVLEVEL_NOTICE    , "DOCSIS 2-way established"},
    {ERRORCODE_B20_0 , DOCSDEVEVLEVEL_NOTICE    , "VCT acquired"},
    {ERRORCODE_B21_0 , DOCSDEVEVLEVEL_NOTICE    , "OCAP launched"},
    {ERRORCODE_B22_0 , DOCSDEVEVLEVEL_ERROR     , "OCAP Startup Error"},
    {ERRORCODE_B23_0 , DOCSDEVEVLEVEL_NOTICE    , "XAIT received"},
    {ERRORCODE_B24_0 , DOCSDEVEVLEVEL_ERROR     , "Error reading XAIT"},
    {ERRORCODE_B25_0 , DOCSDEVEVLEVEL_NOTICE    , "Initial Monitor App launched"},
    {ERRORCODE_B26_0 , DOCSDEVEVLEVEL_NOTICE    , "Initial Monitor App Startup Error"},
    {ERRORCODE_B27_XX, DOCSDEVEVLEVEL_NOTICE    , "Proprietary Condition Met"},
    {ERRORCODE_B28_0 , DOCSDEVEVLEVEL_NOTICE    , "Host Image Download Complete"},
    {ERRORCODE_B29_0 , DOCSDEVEVLEVEL_ERROR     , "Common Download CVT Error"},
    {ERRORCODE_B30_0 , DOCSDEVEVLEVEL_ERROR     , "Host Image Download Error, %d"},
    {ERRORCODE_B31_0 , DOCSDEVEVLEVEL_NOTICE    , "Card Image Download Complete"},
};

extern "C" void vlSnmpDocsEventTable_LoadPersistentLog();

void
init_docsDevEventTable(void)
{VL_AUTO_LOCK(vlg_TlvEventDblock);
    /*
        * here we initialize all the tables we're planning on supporting
        */

    initialize_table_docsDevEventTable();
    DocEvtMutex.Acquire();
    {
        vlSnmpDocsEventTable_LoadPersistentLog();
    }
	//auto_unlock_ptr(DocEvtMutex);
    DocEvtMutex.Release();
    //auto_unlock(&vlg_TlvEventDblock);
}

//# Determine the first/last column names

/** Initialize the docsDevEventTable table by defining its contents and how it's structured */
void
initialize_table_docsDevEventTable(void)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    static oid      docsDevEventTable_oid[] =
    { 1, 3, 6, 1, 2, 1, 69, 1, 5, 8 };
    size_t          docsDevEventTable_oid_len =
            OID_LENGTH(docsDevEventTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_tdata  *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache  *cache;

    reg =
            netsnmp_create_handler_registration("docsDevEventTable",
            docsDevEventTable_handler,
            docsDevEventTable_oid,
            docsDevEventTable_oid_len,
            HANDLER_CAN_RONLY);

    table_data = netsnmp_tdata_create_table("docsDevEventTable", 0);
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: docsDevEvIndex */
                                     0);

    table_info->min_column = COLUMN_DOCSDEVEVFIRSTTIME;
    table_info->max_column = COLUMN_DOCSDEVEVTEXT;

    netsnmp_tdata_register(reg, table_data, table_info);
    cache = netsnmp_cache_create(DOCSDEVEVENTTABLE_TIMEOUT,
                                 docsDevEventTable_load,
                                 docsDevEventTable_free,
                                 docsDevEventTable_oid,
                                 docsDevEventTable_oid_len);
    cache->magic =
            (void *) table_data;
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET |
            NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | NETSNMP_CACHE_DONT_FREE_EXPIRED |
            NETSNMP_CACHE_DONT_AUTO_RELEASE;
    netsnmp_inject_handler_before(reg, netsnmp_cache_handler_get(cache),
                                  "docsDevEventTable");

    /*
    * Initialise the contents of the table here
    */

    if(0 == docsDevEventTable_load(cache,table_data))
    {
        //vl_ocStbHostAVInterfaceTable_getdata"
        SNMP_DEBUGPRINT(" ERROR:: Not yet table initialise here \n");
    }
	//auto_unlock(&vlg_TlvEventDblock);
}


/*
 * create a new row in the table
 */
vector<docsDevEventTable_t> docsEventTableList;

netsnmp_tdata_row *docsDevEventTable_createEntry(netsnmp_tdata *
                                                 table_data,
                                                 long docsDevEvIndex)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    struct docsDevEventTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct docsDevEventTable_entry);
    if(!entry){
	 //auto_unlock(&vlg_TlvEventDblock);
        return NULL;
    	}

    row = netsnmp_tdata_create_row();
    if(!row)
    {
        SNMP_FREE(entry);
	 //auto_unlock(&vlg_TlvEventDblock);
        return NULL;
    }

    row->data = entry;
    entry->docsDevEvIndex = docsDevEvIndex;
    netsnmp_tdata_row_add_index(row, ASN_INTEGER,
                                &(entry->docsDevEvIndex),
                                  sizeof(entry->docsDevEvIndex));
    netsnmp_tdata_add_row(table_data, row);
    //auto_unlock(&vlg_TlvEventDblock);
    return row;
}


/*
 * remove a row from the table
 */
void
 docsDevEventTable_removeEntry(netsnmp_tdata * table_data,
                                  netsnmp_tdata_row * row)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    struct docsDevEventTable_entry *entry;

    if (!row){
	 //auto_unlock(&vlg_TlvEventDblock);
        return;                 /* Nothing to remove */
    	}
    entry = (struct docsDevEventTable_entry *)
        netsnmp_tdata_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
	//auto_unlock(&vlg_TlvEventDblock);
}
#ifdef __cplusplus
extern "C" {
#endif
/* Return the localtime in a year-Mon-date-time-zone formate*/
void GetLocalTime_YMDZ(u_char *time_ymdz, size_t* lenght_time)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    time_t installTime;
    installTime = time(NULL);
    memcpy(time_ymdz, date_n_time(&installTime, lenght_time) ,TIME_MAX_CHAR);
//to check the time output values
//RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "date_n_time var_len = %d\n", *lenght_time);
/*for(int ii = 0; ii<12; ii++)
    RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "%d--\n", time_ymdz[ii]);
RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "\n");*/
//auto_unlock(&vlg_TlvEventDblock);
}

static int isz = 1;

extern "C" void vlSnmpDocsEventTable_UpdatePersistentLog(int nTotal, docsDevEventTable_t * pDocsEvObj);
static vector<docsDevEventTable_t> docsEventTableList_backup;

extern "C" void vlSnmpDocsEventTable_ResetLog()
{}

void vlSnmpDocsEventTable_LoadPersistentLog()
{}

void vlSnmpDocsEventTable_UpdatePersistentLog(int nTotal, docsDevEventTable_t * pDocsEvObj)
{}

VL_SNMP_EVENT_MESSAGE_MAP_ENTRY * vlSnmpGetTlvMessageEntry(unsigned long nEventId)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    int i = 0;
    int nMessages = sizeof(TLVEventMess) / sizeof(TLVEventMess[0]);

    if(ERRORCODE_B27_XX == ((nEventId/100)*100))
    {
        nEventId = ERRORCODE_B27_XX;
    }

    for(i = 0; i < nMessages; i++)
    {
        if(nEventId == TLVEventMess[i].nEventId) return (&(TLVEventMess[i]));
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return NULL;
}

int EdocsDevEventhandling(unsigned long nEventId, int eType, int eClient)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    u_char yearMonTime[TIME_MAX_CHAR];
    docsDevEventTable_t docsEvObj;
    size_t datelenght;
    memset(&docsEvObj, 0, sizeof(docsDevEventTable_t));
    memset(yearMonTime, 0, sizeof(yearMonTime));
    GetLocalTime_YMDZ(yearMonTime, &datelenght);
    memcpy(docsEvObj.docsDevEvFirstTime, yearMonTime ,datelenght);
    docsEvObj.docsDevEvFirstTime_len = datelenght;
    docsEvObj.docsDevEvLastTime_len = datelenght;
    memcpy( docsEvObj.docsDevEvLastTime, docsEvObj.docsDevEvFirstTime, docsEvObj.docsDevEvLastTime_len);
    docsEvObj.docsDevEvCounts = 1;
    docsEvObj.docsDevEvId =  nEventId;

    const char* ErrorDesc = NULL; int devlevel = DOCSDEVEVLEVEL_DEBUG;

    VL_SNMP_EVENT_MESSAGE_MAP_ENTRY * pEventMsgMapEntry = vlSnmpGetTlvMessageEntry(nEventId);

    if(NULL != pEventMsgMapEntry)
    {
        ErrorDesc = pEventMsgMapEntry->pszMessage;
        devlevel  = pEventMsgMapEntry->nEventLevel;
    }

    docsEvObj.docsDevEvLevel = devlevel;

    if(NULL != ErrorDesc)
    {
        switch(nEventId)
        {
            case ERRORCODE_D01_0:
            case ERRORCODE_D02_0:
            case ERRORCODE_D03_1:
            case ERRORCODE_D101_0:
            case ERRORCODE_D102_0:
            case ERRORCODE_D103_0:
            case ERRORCODE_D104_0:
            {
                snprintf(docsEvObj.docsDevEvText, DOCS_MAX_CHAR, ErrorDesc, (eClient ? "CC":"eSTB"));
            }
            break;

            case ERRORCODE_I401_1:
            case ERRORCODE_I401_2:
            case ERRORCODE_B30_0:
            {
                snprintf(docsEvObj.docsDevEvText, DOCS_MAX_CHAR, ErrorDesc, eType);
            }
            break;

            case ERRORCODE_B27_XX:
            {
                if(eType != -1) docsEvObj.docsDevEvId += (eType%100);
                snprintf(docsEvObj.docsDevEvText, DOCS_MAX_CHAR, ErrorDesc);
            }
            break;

            default:
            {
                snprintf(docsEvObj.docsDevEvText, DOCS_MAX_CHAR, ErrorDesc);
            }
            break;
        }
    }

    docsEvObj.docsDevEvText_len = strlen(docsEvObj.docsDevEvText);

    DocEvtMutex.Acquire();
    docsEvObj.docsDevEvIndex = docsEventTableList.size()+1;
    vlSnmpDocsEventTable_UpdatePersistentLog(docsEventTableList.size()+1, &docsEvObj);
    for(vector<docsDevEventTable_t>::iterator Res_iter = docsEventTableList.begin(); Res_iter != docsEventTableList.end(); Res_iter++)
    {
        if((0 == strcmp(Res_iter->docsDevEvText, docsEvObj.docsDevEvText)) &&
           (Res_iter->docsDevEvId == docsEvObj.docsDevEvId))
        {
            memcpy(Res_iter->docsDevEvLastTime, (char*)yearMonTime, datelenght);
            Res_iter->docsDevEvLastTime_len = datelenght;
            Res_iter->docsDevEvCounts += 1;
            vlSnmpDocsEventTable_UpdatePersistentLog(docsEventTableList.size(), &(*Res_iter));
            SNMP_DEBUGPRINT("\n Errorflag ::::::::::%d\n",nEventId);
            DocEvtMutex.Release();
            //auto_unlock_ptr(DocEvtMutex);	
            //auto_unlock(&vlg_TlvEventDblock);
	        return 1;
        }
    }
    SNMP_DEBUGPRINT("\n ::::::::::::::: docsEvObj.docsDevEvIndex size  :::  %d\n",isz);
    docsEventTableList.push_back(docsEvObj);
    isz++;

    DocEvtMutex.Release();
    //auto_unlock(&vlg_TlvEventDblock);
    return 1;
}
#ifdef __cplusplus
}
#endif
/*
 * Example cache handling - set up table_data list from a suitable file
 */
int docsDevEventTable_load(netsnmp_cache * cache, void *vmagic)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    netsnmp_tdata * table_data = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *row;

    SNMP_DEBUGPRINT("\n docsDevEventTable_load :: Start docsDevEventTable_load   :::  \n");
    bool replace_table = false;
    int count = 0;

    if(netsnmp_tdata_row_first(table_data))
    {
        replace_table = true;
    }
    /**to make a back if the undo after resetlog :: for EventControl.cpp*/

    // Apr-17-2009: moved handling of resetLog to docsDevEvControl.cpp
    // Apr-17-2009: moved handling of useDefaultReporting to docsDevEvControl.cpp

    // #endif //if 0
    /**End resetlog :: for EventControl.cpp*/

    for(vector<docsDevEventTable_t>::iterator Res_iter = docsEventTableList.begin();
        Res_iter != docsEventTableList.end(); Res_iter++)
    {
        if(replace_table)
        {
            replace_table = false;
            Table_free(table_data);
        }

        docsDevEventTable_t docsEvObj;
        memset(&docsEvObj, 0, sizeof(docsDevEventTable_t));
        SNMP_DEBUGPRINT("\n vector<docsDevEventTable_t>::iterator Res_iter  :::  \n");

        docsEvObj.docsDevEvIndex = Res_iter->docsDevEvIndex;
        docsEvObj.docsDevEvFirstTime_len = Res_iter->docsDevEvFirstTime_len;
        memcpy( docsEvObj.docsDevEvFirstTime, Res_iter->docsDevEvFirstTime, Res_iter->docsDevEvFirstTime_len);
        docsEvObj.docsDevEvLastTime_len =  Res_iter->docsDevEvLastTime_len;
        memcpy( docsEvObj.docsDevEvLastTime, Res_iter->docsDevEvLastTime, Res_iter->docsDevEvLastTime_len);
        docsEvObj.docsDevEvCounts =  Res_iter->docsDevEvCounts;
        docsEvObj.docsDevEvLevel = Res_iter->docsDevEvLevel;
        docsEvObj.docsDevEvId =  Res_iter->docsDevEvId;
        docsEvObj.docsDevEvText_len = Res_iter->docsDevEvText_len;
        memcpy(docsEvObj.docsDevEvText,  Res_iter->docsDevEvText, Res_iter->docsDevEvText_len);
        docsDevEventTable_createEntry_allData(table_data, &docsEvObj);

    }
    if(docsEventTableList.size() == 0)
    {
        Table_free(table_data);
        docsDevEventTable_t ListDoscEvent;
        memset(&ListDoscEvent ,0,sizeof(ListDoscEvent));
        ListDoscEvent.docsDevEvIndex = 1;
        docsDevEventTable_createEntry_allData(table_data, &ListDoscEvent);
    }
    SNMP_DEBUGPRINT("\n docsDevEventTable_load :: End docsDevEventTable_load   :::  \n");
    //auto_unlock(&vlg_TlvEventDblock);
    return 1;
}

int docsDevEventTable_createEntry_allData(netsnmp_tdata * table_data, docsDevEventTable_t *ListDoscEvent)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    SNMP_DEBUGPRINT("\n docsDevEventTable_createEntry_allData ::Start \n");
    struct docsDevEventTable_entry *entry;
    netsnmp_tdata_row *row;
    entry = SNMP_MALLOC_TYPEDEF(struct docsDevEventTable_entry);

    if (!entry){
	 //auto_unlock(&vlg_TlvEventDblock);
        return 0;
    }
    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
	 //auto_unlock(&vlg_TlvEventDblock);
        return 0;
    }
    row->data = entry;

    entry->docsDevEvIndex =  ListDoscEvent->docsDevEvIndex;
    /*
    * Column values
    */
    entry->docsDevEvFirstTime_len = ListDoscEvent->docsDevEvFirstTime_len;
    memcpy(entry->docsDevEvFirstTime,ListDoscEvent->docsDevEvFirstTime, entry->docsDevEvFirstTime_len);
    entry->docsDevEvLastTime_len = ListDoscEvent->docsDevEvLastTime_len;
    memcpy(entry->docsDevEvLastTime,ListDoscEvent->docsDevEvLastTime ,entry->docsDevEvLastTime_len);
    entry->docsDevEvCounts = ListDoscEvent->docsDevEvCounts;
    entry->docsDevEvLevel = ListDoscEvent->docsDevEvLevel;
    entry->docsDevEvId   = ListDoscEvent->docsDevEvId;
    entry->docsDevEvText_len = ListDoscEvent->docsDevEvText_len;
    memcpy(entry->docsDevEvText, ListDoscEvent->docsDevEvText ,entry->docsDevEvText_len);
    netsnmp_tdata_row_add_index(row, ASN_UNSIGNED,
                                &(entry->docsDevEvIndex),
                                  sizeof(entry->docsDevEvIndex));
    netsnmp_tdata_add_row(table_data, row);

    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvIndex = %d\n", entry->docsDevEvIndex);
    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvCounts = %d\n", entry->docsDevEvCounts);
    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvLevel = %d\n", entry->docsDevEvLevel);
    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvId = %d\n", entry->docsDevEvId);
    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvFirstTime_len = %d\n", entry->docsDevEvFirstTime_len);
    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvLastTime_len = %d\n", entry->docsDevEvLastTime_len);
    SNMP_DEBUGPRINT("docsDevEventEntry.docsDevEvText_len = %d\n", entry->docsDevEvText_len);

    SNMP_DEBUGPRINT("\n docsDevEventTable_createEntry_allData ::END \n");
    //auto_unlock(&vlg_TlvEventDblock);
    return 1;
}

void docsDevEventTable_free(netsnmp_cache * cache, void *vmagic)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    /*netsnmp_tdata * table = (netsnmp_tdata *) vmagic;
    netsnmp_tdata_row *this;

    while           ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
}*/
//auto_unlock(&vlg_TlvEventDblock);
}
/** handles requests for the docsDevEventTable table */ int
  docsDevEventTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata * table_data;
    netsnmp_tdata_row *table_row;
    netsnmp_tdata * vl_table_data;
    netsnmp_tdata_row *vl_row;
    struct docsDevEventTable_entry *table_entry;
    int             ret;

    vl_row = NULL;
    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            //table_entry = (struct docsDevEventTable_entry *)                netsnmp_tdata_extract_entry(request);
            /*changed due to wrong values in retriving first element of the Table*/
            VL_SNMP_PREPARE_AND_CHECK_TABLE_GET_REQUEST(docsDevEventTable_entry);

            switch (table_info->colnum) {
            case COLUMN_DOCSDEVEVFIRSTTIME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         docsDevEvFirstTime,
                                         table_entry->
                                         docsDevEvFirstTime_len);
                break;
            case COLUMN_DOCSDEVEVLASTTIME:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         docsDevEvLastTime,
                                         table_entry->
                                         docsDevEvLastTime_len);
                break;
            case COLUMN_DOCSDEVEVCOUNTS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_COUNTER,
                                           table_entry->docsDevEvCounts);
                break;
            case COLUMN_DOCSDEVEVLEVEL:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->docsDevEvLevel);
                break;
            case COLUMN_DOCSDEVEVID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->docsDevEvId);
                break;
            case COLUMN_DOCSDEVEVTEXT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *) table_entry->
                                         docsDevEvText,
                                         table_entry->docsDevEvText_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    //auto_unlock(&vlg_TlvEventDblock);
    return SNMP_ERR_NOERROR;
}
