/*
* If not stated otherwise in this file or this component's LICENSE file the
* following copyright and licenses apply:
*
* Copyright 2011 RDK Management
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */
#include "vlMutex.h"
#include "TlvConfigObjs.h"
#include "Tlvevent.h"
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ocStbHostDumpTrapInfo.h"
#include "SnmpIORM.h"
#include "snmp_types.h"
#include "vlSnmpClient.h"
#include "persistentconfig.h"
#include "utilityMacros.h"
#include "xchanResApi.h"
#include "cardManagerIf.h"
#include "hostInfo.h"
#include "rdk_debug.h"
#include "vlSnmpHostInfo.h"
#include "ipcclient_impl.h"


static vlMutex & vlg_TlvEventDblock = TlvConfig::vlGetTlvEventDbLock();

#define OCSTBHOSTDUMPNOW_TRUE           1
#define OCSTBHOSTDUMPNOW_FALSE          2
#ifdef AUTO_LOCKING

static void auto_lock(rmf_osal_Mutex *mutex)
{

               if(!mutex) 
			   	RDK_LOG(RDK_LOG_ERROR, "LOG.RDK.POD","\n\n\n\n %s: Mutex is NULL \n\n\n", __FUNCTION__);
		 rmf_osal_mutexAcquire(*mutex);
}

static void auto_unlock(rmf_osal_Mutex *mutex)
{
         if(mutex)
		 rmf_osal_mutexRelease(*mutex);
}
#endif

/** Initializes the ocStbHostDumpTrapInfo module */
void
init_ocStbHostDumpTrapInfo(void)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    static oid      ocStbHostDumpEventCount_oid[] =
    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 1 };
    static oid      ocStbHostDumpNow_oid[] =
    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 2 };
    static oid      ocStbHostDumpEventTimeout_oid[] =
    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 3 };
    static oid      ocStbHostDumpFilePath_oid[] =
    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 4 };

    DEBUGMSGTL(("ocStbHostDumpTrapInfo", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("ocStbHostDumpEventCount",
             handle_ocStbHostDumpEventCount,
             ocStbHostDumpEventCount_oid,
             OID_LENGTH(ocStbHostDumpEventCount_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("ocStbHostDumpNow", handle_ocStbHostDumpNow,
             ocStbHostDumpNow_oid,
             OID_LENGTH(ocStbHostDumpNow_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("ocStbHostDumpEventTimeout",
             handle_ocStbHostDumpEventTimeout,
             ocStbHostDumpEventTimeout_oid,
             OID_LENGTH(ocStbHostDumpEventTimeout_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("ocStbHostDumpFilePath",
             handle_ocStbHostDumpFilePath,
             ocStbHostDumpFilePath_oid,
             OID_LENGTH(ocStbHostDumpFilePath_oid),
             HANDLER_CAN_RONLY));
	      //auto_unlock(&vlg_TlvEventDblock);
}


static int Old_g_EventCount = 0;
static unsigned int  g_DumpNow = OCSTBHOSTDUMPNOW_FALSE;//enum true=1 ,false = 2
static int Old_g_DumpNow = OCSTBHOSTDUMPNOW_FALSE;//enum true=1 ,false = 2
static unsigned int g_EventTimeOut = 5; // 1..120
static unsigned int Old_g_EventTimeOut = 5; // 1..120
int g_EventCount= 0;
#define PANIC_DUMP_DIRECTORY  "/opt/"
char g_DumpFIlePath[API_CHRMAX]=PANIC_DUMP_DIRECTORY;//Default location later it has to be changed to specified destionation wher the manufacture want


static int vlSnmpGetSetTrapDumpEventCount(int nNewValue = -1)
{
	return 0;
}

int vlSnmpGetTrapDumpEventCount()
{VL_AUTO_LOCK(vlg_TlvEventDblock);
    int ret = 0;
    ret = vlSnmpGetSetTrapDumpEventCount();
    //auto_unlock(&vlg_TlvEventDblock);
    return ret;
}

void vlSnmpSetTrapDumpEventCount(int nNewValue)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    vlSnmpGetSetTrapDumpEventCount(nNewValue);
    //auto_unlock(&vlg_TlvEventDblock);
}

int vlSnmpDecrementTrapDumpEventCount()
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    int nCurrentValue = vlSnmpGetTrapDumpEventCount();
    if(nCurrentValue > 0)
    {
        vlSnmpSetTrapDumpEventCount(nCurrentValue-1);
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return nCurrentValue;
}

#define VL_SNMP_CRC_INIT    0xFFFFFFFF

static unsigned long vlg_dumpFileCRC = VL_SNMP_CRC_INIT;
extern "C" unsigned long Crc32(unsigned crcAccum, unsigned char *pData, int len);

int vlSnmpWriteValueToFile(FILE * fp, int nBytes, unsigned long long lValue)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    unsigned char buffer[sizeof(lValue)];
    VL_BYTE_STREAM_INST(FileBuf, WriteBuf, buffer, sizeof(buffer));
    vlWriteNByteLong(pWriteBuf, nBytes, lValue);
    vlg_dumpFileCRC = Crc32(vlg_dumpFileCRC, buffer, nBytes);
    //auto_unlock(&vlg_TlvEventDblock);
    return fwrite(buffer, 1, nBytes, fp);
}

int vlSnmpWriteBufferToFile(FILE * fp, int nBytes, void * pBuffer)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    vlg_dumpFileCRC = Crc32(vlg_dumpFileCRC, (unsigned char*)pBuffer, nBytes);
    //auto_unlock(&vlg_TlvEventDblock);
    return fwrite(pBuffer, 1, nBytes, fp);
}

unsigned long long vlSnmpGetCurrentNtpTime()
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    struct timeval tv;
    memset(&tv,0,sizeof(tv));
    
    gettimeofday(&tv, NULL);
    time_t ntpCurrentTime = tv.tv_sec;
    time_t offsetTime = 2208960000; // offset from 1970
    
    unsigned long long ntpTime = (ntpCurrentTime+offsetTime);
    ntpTime <<= 32;
    
    // fractional part of a second (each usec occupies 4295 parts in 2^32)
    // this is a poorer resolution than the required 1 part in 2^32
    // (which is equivalent to a resolution of 200 pico-secs).
    unsigned long usec = ((unsigned long)(tv.tv_usec)*4295);
    
    ntpTime |= usec; 
    
    RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SNMP", "%s: Current Time = %u, NTP Time = %llX\n", __FUNCTION__, ntpCurrentTime, ntpTime);
    //auto_unlock(&vlg_TlvEventDblock);
    return ntpTime;
}

extern vector<v3NotificationReceiver_t> vlg_snmp_agent_NotificationReceiverList;


VL_SNMP_API_RESULT vlSnmpSendOchdTrapNotification(const char * pszFilePath)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    string strIpAddress;
    char szTrapCommunity[] = "public";
    char szTrapOid[] = "OC-STB-HOST-MIB::ocStbPanicDumpTrap.0";
    char szFilePath[API_CHRMAX] = "";
    strncpy(szFilePath, pszFilePath, API_CHRMAX);
    szFilePath [API_CHRMAX - 1] = 0;	
    
    VL_SNMP_CLIENT_VALUE aResults[] =
    {
        VL_SNMP_CLIENT_MULTI_SET_STR_ENTRY((char*)"OC-STB-HOST-MIB::ocStbHostDumpFilePath.0", 's', szFilePath  ),
    };
    int nResults = VL_ARRAY_ITEM_COUNT(aResults);
    
    VL_SNMP_API_RESULT result = VL_SNMP_API_RESULT_SUCCESS;
    
    // send trap / inform to configured trap receivers (in snmpd.conf)
    result =
            vlSnmpSendNotificationSimple(
                "",
                "",
                szTrapOid,
                &nResults, aResults,
                VL_SNMP_CLIENT_REQUEST_TYPE_TRAP);
    
    // send inform to registered inform receivers
    for(int i = 0; i < vlg_snmp_agent_NotificationReceiverList.size(); i++)
    {
        v3NotificationReceiver_t receiver = vlg_snmp_agent_NotificationReceiverList[i];
        VL_SNMP_CLIENT_REQUEST_TYPE eRequestType = VL_SNMP_CLIENT_REQUEST_TYPE_TRAP;
        
        switch(receiver.eV3TrapType)
        {
            case VL_TLV_217_NOTIFY_TRAP_V1:
            case VL_TLV_217_NOTIFY_TRAP_V2C:
            case VL_TLV_217_NOTIFY_INFORM_V2C:
            {
                // nothing to do, already done before for loop.
                continue;
            }
            break;
            
            case VL_TLV_217_NOTIFY_TRAP_V2C_IN_V3:
            {
                eRequestType = VL_SNMP_CLIENT_REQUEST_TYPE_TRAP;
            }
            break;
            
            case VL_TLV_217_NOTIFY_INFORM_V2C_IN_V3:
            {
                eRequestType = VL_SNMP_CLIENT_REQUEST_TYPE_INFORM;
            }
            break;
        
            default:
            {
                // don't know what to do
                continue;
            }
            break;
        }
        
        if(receiver.v3ipV4address.size() > 0)
        {
            strIpAddress = VL_TLV_TRANSPORT_ADDR_AND_MASK::getAddrString(receiver.v3ipV4address);
            result =
                    vlSnmpSendNotificationComplex(
                        szTrapCommunity,
                        strIpAddress.c_str(),
                        szTrapOid,
                        receiver.nV3UdpPortNumber, receiver.nV3Timeout, receiver.nV3Retries,
                        &nResults, aResults,
                        eRequestType);
        }
        if(receiver.v3ipV6address.size() > 0)
        {
            strIpAddress = VL_TLV_TRANSPORT_ADDR_AND_MASK::getAddrString(receiver.v3ipV6address);
            result =
                    vlSnmpSendNotificationComplex(
                        szTrapCommunity,
                        strIpAddress.c_str(),
                        szTrapOid,
                        receiver.nV3UdpPortNumber, receiver.nV3Timeout, receiver.nV3Retries,
                        &nResults, aResults,
                        eRequestType);
        }
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return result;
}

extern "C" void vlSnmpGeneratePanicTrapDump(void* _pReport)
	//long _pReport
    VL_SNMP_Panic_Dump_Report * pReport = ((VL_SNMP_Panic_Dump_Report*)_pReport);
    if(NULL == pReport)
    {
        static VL_SNMP_Panic_Dump_Report emptyReport;
        memset(&emptyReport,0,sizeof(emptyReport));
        emptyReport.eReportType = VL_SNMP_PANIC_REPORT_TYPE_FORCED;
        pReport = &emptyReport;
    }
    
    if(NULL != pReport)
    {
        g_EventCount = vlSnmpDecrementTrapDumpEventCount();
        if(g_EventCount > 0)
        {
            // dump trap info
            VL_HOST_IP_INFO hostIpInfo;
            unsigned char cardMacAddress[VL_MAC_ADDR_SIZE];
            char szSysDescr[API_CHRMAX];
            memset(cardMacAddress, 0, sizeof(cardMacAddress));
            int nTotalRAM = 0;
            int nFreeRAM = 0;
            int nAllocatedRAM = 0;
            int nLargestFreeBlock = 0;
            int nJvmHeapSize = 0;
            IPC_CLIENT_vlXchanGetDsgIpInfo(&hostIpInfo);
            { // proc info
                #define PROC_MEMINFO_PATH "/proc/meminfo"
                    
                FILE *fp;
                char str[128];
                char type[128];
                char val[128];
                int i = 0;
        
                memset(&str,0,sizeof(str));
    
                if ((fp = fopen(PROC_MEMINFO_PATH, "r")) != NULL)
                {
                    while((fgets(str, sizeof(str), fp)) != NULL)
                    {
                        sscanf(str, "%s%s", type,val);
                        //RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SNMP", "<%s> <%s>\n", type, val);
                
                        if(0 == strcmp("MemTotal:", type))
                        {
                            nTotalRAM = atoi(val);
                            nAllocatedRAM = nTotalRAM - nFreeRAM;
                        }
                            
                        if(0 == strcmp("MemFree:", type))
                        {
                            nFreeRAM = atoi(val);
                            nAllocatedRAM = nTotalRAM - nFreeRAM;
                        }
                    }// while
                    if(NULL != fp) fclose(fp);
                }// (NULL != fopen())
            } // proc info
            
            {// SNMP get
                int  nVal = 0;
                VL_SNMP_CLIENT_VALUE aResults[] =
                {
                    VL_SNMP_CLIENT_MULTI_VAR_ENTRY((char*)"SNMPv2-MIB::sysDescr.0" , VL_SNMP_CLIENT_VALUE_TYPE_BYTE, sizeof(szSysDescr) , szSysDescr   ),
                    VL_SNMP_CLIENT_MULTI_VAR_ENTRY((char*)"OC-STB-HOST-MIB::ocStbHostCardMacAddress.0" , VL_SNMP_CLIENT_VALUE_TYPE_BYTE, sizeof(cardMacAddress) , cardMacAddress   ),
                    VL_SNMP_CLIENT_MULTI_VAR_ENTRY((char*)"OC-STB-HOST-MIB::ocStbHostLargestAvailableBlock.0" , VL_SNMP_CLIENT_VALUE_TYPE_INTEGER, 1 , &nLargestFreeBlock   ),
                    VL_SNMP_CLIENT_MULTI_VAR_ENTRY((char*)"OC-STB-HOST-MIB::ocStbHostJVMHeapSize.0" , VL_SNMP_CLIENT_VALUE_TYPE_INTEGER, 1 , &nJvmHeapSize   ),
                };
                int nResults = VL_ARRAY_ITEM_COUNT(aResults);
                vlSnmpGetLocalObjects(NULL, &nResults, aResults);
            } // SNMP get
            
            char szFilePath[API_CHRMAX];
            snprintf(szFilePath, sizeof(szFilePath), "%02X%02X%02X%02X%02X%02X.dmp",
                    hostIpInfo.aBytMacAddress[0], hostIpInfo.aBytMacAddress[1],
                    hostIpInfo.aBytMacAddress[2], hostIpInfo.aBytMacAddress[3],
                    hostIpInfo.aBytMacAddress[4], hostIpInfo.aBytMacAddress[5]
                );
            time_t tTime = time(NULL);
            struct tm * pTm = localtime(&tTime);
            if(NULL != pTm)
            {
                snprintf(szFilePath, sizeof(szFilePath), "%02X%02X%02X%02X%02X%02X%02d%02d%02d%05d.dmp",
                        hostIpInfo.aBytMacAddress[0], hostIpInfo.aBytMacAddress[1],
                        hostIpInfo.aBytMacAddress[2], hostIpInfo.aBytMacAddress[3],
                        hostIpInfo.aBytMacAddress[4], hostIpInfo.aBytMacAddress[5],
                        (pTm->tm_mon+1), pTm->tm_mday, ((pTm->tm_year)%100),
                        ((pTm->tm_hour)*3600 + (pTm->tm_min)*60 + (pTm->tm_sec))
                    );
            }
            
            int ret = 0;			
            snprintf(g_DumpFIlePath, sizeof(g_DumpFIlePath), "%s%s", PANIC_DUMP_DIRECTORY, szFilePath);
            FILE * fp = fopen(g_DumpFIlePath, "w");
            int nTotalBytes = 0;
            if(NULL != fp)
            {
                RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SNMP", "%s: fopen('%s') succeeded\n", __FUNCTION__, g_DumpFIlePath);
                vlg_dumpFileCRC = VL_SNMP_CRC_INIT;
                
                nTotalBytes += vlSnmpWriteValueToFile(fp, 1, 1); // Protocol Header Type
                nTotalBytes += vlSnmpWriteValueToFile(fp, 1, 1); // Protocol Version
                nTotalBytes += vlSnmpWriteValueToFile(fp, 1, g_EventTimeOut); // Event Timeout
                nTotalBytes += vlSnmpWriteBufferToFile(fp, VL_MAC_ADDR_SIZE, cardMacAddress); // MAC Address
                nTotalBytes += vlSnmpWriteValueToFile(fp, 1, strlen(szSysDescr)); // Platform Id Length
                nTotalBytes += vlSnmpWriteBufferToFile(fp, strlen(szSysDescr), szSysDescr); // Platform Id
                nTotalBytes += vlSnmpWriteValueToFile(fp, 8, vlSnmpGetCurrentNtpTime()); // Time Stamp
                nTotalBytes += vlSnmpWriteValueToFile(fp, 1, pReport->eReportType); // Message Type
                nTotalBytes += vlSnmpWriteValueToFile(fp, 4, nFreeRAM*1024); // Free RAM
                nTotalBytes += vlSnmpWriteValueToFile(fp, 4, nAllocatedRAM*1024); // Allocated RAM
                nTotalBytes += vlSnmpWriteValueToFile(fp, 4, nLargestFreeBlock*1024); // Largest Free RAM
                nTotalBytes += vlSnmpWriteValueToFile(fp, 4, nJvmHeapSize*1024); // JVM heap size
                
                nTotalBytes += vlSnmpWriteValueToFile(fp, 2, pReport->nReportBytes+nTotalBytes+6); // File Size
                
                if((NULL != pReport->pReportBytes) && (pReport->nReportBytes > 0))
                {
                    nTotalBytes += vlSnmpWriteBufferToFile(fp, pReport->nReportBytes, pReport->pReportBytes); // Platform Id
                }
                
                nTotalBytes += vlSnmpWriteValueToFile(fp, 4, vlg_dumpFileCRC); // CRC
                
                fflush(fp);
                fclose(fp);
                
                RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SNMP", "%s: wrote %d bytes to '%s'. Sending Trap...\n", __FUNCTION__, nTotalBytes, g_DumpFIlePath);
                
                vlSnmpSendOchdTrapNotification(g_DumpFIlePath);

                rmf_osal_threadSleep(g_EventTimeOut*1000, 0); // Wait for TFTP event, if TFTP occurs then wait till TFTP completes.
                RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SNMP", "%s: deleting '%s' and rebooting...\n", __FUNCTION__, g_DumpFIlePath);
                ret = remove(g_DumpFIlePath);
                if( ret !=0  )        
                {
                    RDK_LOG(RDK_LOG_ERROR,"LOG.RDK.SNMP","%s() : Could not remove file \n", __FUNCTION__);
                }                  
            } // NULL != fp
        } // g_EventCount > 0
        
        switch(pReport->eReportType)
        {
            case VL_SNMP_PANIC_REPORT_TYPE_FORCED:
            {
                RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SYS", "\n vlSnmpGeneratePanicTrapDump(): Rebooting to handle VL_SNMP_PANIC_REPORT_TYPE_FORCED \n");
                vlSnmpRebootHost(VL_SNMP_HOST_REBOOT_INFO_user);
            }
            break;
            
            case VL_SNMP_PANIC_REPORT_TYPE_EXCEPTION:
            default:
            {
                RDK_LOG(RDK_LOG_INFO, "LOG.RDK.SYS", "\n vlSnmpGeneratePanicTrapDump(): Rebooting to handle VL_SNMP_PANIC_REPORT_TYPE_EXCEPTION \n");
                vlSnmpRebootHost(VL_SNMP_HOST_REBOOT_INFO_trap);
            }
        }
    } // NULL != pReport
    //auto_unlock(&vlg_TlvEventDblock);
}
int
        handle_ocStbHostDumpEventCount(netsnmp_mib_handler *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info *reqinfo,
                                       netsnmp_request_info *requests)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    int             ret;
    unsigned int  set_EventCount;

    /*
    * We are never called for a GETNEXT if it's registered as a
    * "instance", as it's "magically" handled for us.
    */

    /*
    * a instance handler also only hands us one request at a time, so
    * we don't need to loop over a list of requests; we'll only get one.
    */

    switch (reqinfo->mode) {

        case MODE_GET:
            g_EventCount = vlSnmpGetTrapDumpEventCount();
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *)&g_EventCount
                                             /* a pointer to the scalar's data */
                                             ,sizeof(g_EventCount)
                                 /*
                                             *  the length of the data in bytes
                                             */ );
            break;

        /*
            * SET REQUEST
            *
         * multiple states in the transaction.  See:
            * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
        */
        case MODE_SET_RESERVE1:
        /*
            * or you could use netsnmp_check_vb_type_and_size instead
        */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (ret != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, ret);
            }
            else
            {
                set_EventCount = *requests->requestvb->val.integer;
            }
            break;

        case MODE_SET_RESERVE2:
        /*
            * XXX malloc "undo" storage buffer
        */
//             set_EventCount = 0;
//             if ( set_EventCount != 0 ) {
//                 netsnmp_set_request_error(reqinfo, requests,
//                                           SNMP_ERR_WRONGVALUE);
//             }
            set_EventCount = *requests->requestvb->val.integer;
            break;

        case MODE_SET_FREE:
        /*
            * XXX: free resources allocated in RESERVE1 and/or
            * RESERVE2.  Something failed somewhere, and the states
            * below won't be called.
            */
//             set_EventCount = 0;
            break;

        case MODE_SET_ACTION:
        /*
            * XXX: perform the value change here
            */
            set_EventCount = *requests->requestvb->val.integer;
//            if ( set_EventCount < 0 || set_EventCount > 32 )
            if ( set_EventCount > 32 )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            else
            {
                set_EventCount = *requests->requestvb->val.integer;
            }
            break;

        case MODE_SET_COMMIT:
        /*
            * XXX: delete temporary storage
         */
            set_EventCount = *requests->requestvb->val.integer;
//            if ( set_EventCount < 0 || set_EventCount > 32 )				
            if ( set_EventCount > 32 )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            else
            {
                Old_g_EventCount = g_EventCount;
                g_EventCount  = set_EventCount;
                vlSnmpSetTrapDumpEventCount(g_EventCount);
            }
            /*if ( g_EventCount == Old_g_EventCount) {
                // try _really_really_ hard to never get to this point
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }*/
            break;

        case MODE_SET_UNDO:
        /*
            * XXX: UNDO and return to previous value for the object
            */
            set_EventCount = *requests->requestvb->val.integer;
            /*g_EventCount = Old_g_EventCount;
            if ( g_EventCount == set_EventCount ) {
            
            // try _really_really_ hard to never get to this point
            netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_UNDOFAILED);
            }*/
            break;

        default:
        /*
            * we should never get here, so this is a really bad error
        */
            snmp_log(LOG_ERR,
                     "unknown mode (%d) in handle_ocStbHostDumpEventCount\n",
                     reqinfo->mode);
	     //auto_unlock(&vlg_TlvEventDblock);
            return SNMP_ERR_GENERR;
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return SNMP_ERR_NOERROR;
}

int
        handle_ocStbHostDumpNow(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    int             ret;
    unsigned int  set_DumpNow = 0;

    /*
    * We are never called for a GETNEXT if it's registered as a
    * "instance", as it's "magically" handled for us.
    */

    /*
    * a instance handler also only hands us one request at a time, so
    * we don't need to loop over a list of requests; we'll only get one.
    */

    switch (reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *)&g_DumpNow, sizeof(g_DumpNow));
            SNMP_DEBUGPRINT("\n MODE_GET 1=true/2=false g_DumpNow values is ::---- %d \n",g_DumpNow);
            break;

        /*
            * SET REQUEST
            *
         * multiple states in the transaction.  See:
            * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
        */
        case MODE_SET_RESERVE1:
        /*
            * or you could use netsnmp_check_vb_type_and_size instead
        */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (ret != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, ret);
            }
            else
            {
                set_DumpNow = *requests->requestvb->val.integer;
            }
            SNMP_DEBUGPRINT("\nMODE_SET_RESERVE1  1=true/2=false set_DumpNow values is ::---- %d \n",set_DumpNow);
            break;

        case MODE_SET_RESERVE2:
        /*
            * XXX malloc "undo" storage buffer
        */
//             if ( /* XXX if malloc, or whatever, failed: */ ) {
//                 netsnmp_set_request_error(reqinfo, requests,
//                                           SNMP_ERR_WRONGVALUE);
//             }
            break;

        case MODE_SET_FREE:
        /*
            * XXX: free resources allocated in RESERVE1 and/or
            * RESERVE2.  Something failed somewhere, and the states
            * below won't be called.
        */
            break;

        case MODE_SET_ACTION:
        /*
            * XXX: perform the value change here
            */
            set_DumpNow = *requests->requestvb->val.integer;
            if ( set_DumpNow != OCSTBHOSTDUMPNOW_FALSE && set_DumpNow != OCSTBHOSTDUMPNOW_TRUE ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE/* some error */
                                        );
            }
            SNMP_DEBUGPRINT("\n MODE_SET_ACTION  1=true/2=false set_DumpNow values is ::---- %d \n",set_DumpNow);

            break;

        case MODE_SET_COMMIT:
        /*
            * XXX: delete temporary storage
            */
            set_DumpNow = *requests->requestvb->val.integer;
            Old_g_DumpNow  = g_DumpNow;
            if ( set_DumpNow != OCSTBHOSTDUMPNOW_FALSE && set_DumpNow != OCSTBHOSTDUMPNOW_TRUE ) {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            else
            {
                g_DumpNow  = set_DumpNow;
            }
            
            SNMP_DEBUGPRINT("\n MODE_SET_COMMIT  1=true/2=false g_DumpNow values is ::---- %d \n",g_DumpNow);
            // revert to FALSE
            g_DumpNow = OCSTBHOSTDUMPNOW_FALSE;
	     rmf_osal_ThreadId threadId;
	     rmf_osal_threadCreate(vlSnmpGeneratePanicTrapDump, NULL, RMF_OSAL_THREAD_PRIOR_DFLT, RMF_OSAL_THREAD_STACK_SIZE, &threadId, "vlSnmpGeneratePanicTrapDump");
            break;

        case MODE_SET_UNDO:
        /*
            * XXX: UNDO and return to previous value for the object
            */
            set_DumpNow = *requests->requestvb->val.integer;
            /*g_DumpNow  = Old_g_DumpNow;
            if ( g_DumpNow ==  set_DumpNow) {
                // try _really_really_ hard to never get to this point
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_UNDOFAILED);
            }*/
            SNMP_DEBUGPRINT("\n MODE_SET_UNDO  1=true/2=false g_DumpNow values is ::---- %d \n",g_DumpNow);
            break;

        default:
        /*
            * we should never get here, so this is a really bad error
        */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ocStbHostDumpNow\n",
                     reqinfo->mode);
	     //auto_unlock(&vlg_TlvEventDblock);
            return SNMP_ERR_GENERR;
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return SNMP_ERR_NOERROR;
}

int
        handle_ocStbHostDumpEventTimeout(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration *reginfo,
                                         netsnmp_agent_request_info *reqinfo,
                                         netsnmp_request_info *requests)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    int             ret;
    unsigned int  set_EventTimeOut;
    /*
    * We are never called for a GETNEXT if it's registered as a
    * "instance", as it's "magically" handled for us.
    */

    /*
    * a instance handler also only hands us one request at a time, so
    * we don't need to loop over a list of requests; we'll only get one.
    */

    switch (reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
                                     (u_char *)&g_EventTimeOut
                                             /* XXX: a pointer to the scalar's data */
                                             ,sizeof(g_EventTimeOut)
                                 /*
                                     * XXX: the length of the data in bytes
                                     */ );
            break;

        /*
            * SET REQUEST
            *
         * multiple states in the transaction.  See:
            * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
        */
        case MODE_SET_RESERVE1:
        /*
            * or you could use netsnmp_check_vb_type_and_size instead
        */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (ret != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, ret);
            }
            else
            {
                set_EventTimeOut = *requests->requestvb->val.integer;
            }
            break;

        case MODE_SET_RESERVE2:
        /*
            * XXX malloc "undo" storage buffer
        */
//             if ( /* XXX if malloc, or whatever, failed: */ ) {
//                 netsnmp_set_request_error(reqinfo, requests,
//                                           SNMP_ERR_WRONGVALUE);
//             }
            break;

        case MODE_SET_FREE:
        /*
            * XXX: free resources allocated in RESERVE1 and/or
            * RESERVE2.  Something failed somewhere, and the states
            * below won't be called.
        */
            break;

        case MODE_SET_ACTION:
        /*
            * XXX: perform the value change here
            */
            set_EventTimeOut = *requests->requestvb->val.integer;
            if ( set_EventTimeOut < 1 || set_EventTimeOut > 120 /*non Negitive*/) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE
                                         );
            }
            break;

        case MODE_SET_COMMIT:
            set_EventTimeOut = *requests->requestvb->val.integer;
            if ( set_EventTimeOut < 1 || set_EventTimeOut > 120 /*non Negitive*/) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED
                                         );
            }
            else
            {
                Old_g_EventTimeOut = g_EventTimeOut;
                g_EventTimeOut = set_EventTimeOut;
            }
            /*if ( g_EventTimeOut ==  Old_g_EventTimeOut) {
                // try _really_really_ hard to never get to this point
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }*/
            break;

        case MODE_SET_UNDO:
            /*
            * XXX: UNDO and return to previous value for the object
            */
            set_EventTimeOut = *requests->requestvb->val.integer;
            /*g_EventTimeOut == Old_g_EventTimeOut;
            if ( g_EventTimeOut ==  set_EventTimeOut) {
                //try _really_really_ hard to never get to this point
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_UNDOFAILED);
            }*/
            break;

        default:
        /*
            * we should never get here, so this is a really bad error
        */
            snmp_log(LOG_ERR,
                     "unknown mode (%d) in handle_ocStbHostDumpEventTimeout\n",
                     reqinfo->mode);
	     //auto_unlock(&vlg_TlvEventDblock);
            return SNMP_ERR_GENERR;
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return SNMP_ERR_NOERROR;
}

int
        handle_ocStbHostDumpFilePath(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{VL_AUTO_LOCK(vlg_TlvEventDblock);

    /*
    * We are never called for a GETNEXT if it's registered as a
    * "instance", as it's "magically" handled for us.
    */

    /*
    * a instance handler also only hands us one request at a time, so
    * we don't need to loop over a list of requests; we'll only get one.
    */

    switch (reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *)g_DumpFIlePath
                                             /* g_DumpFIlePath: a pointer to the scalar's data */
                                             ,strlen(g_DumpFIlePath)
                                 /*                                             * g_DumpFIlePath: the length of the data in bytes
                                     */ );
            break;


        default:
        /*
            * we should never get here, so this is a really bad error
        */
            snmp_log(LOG_ERR,
                     "unknown mode (%d) in handle_ocStbHostDumpFilePath\n",
                     reqinfo->mode);
	     //auto_unlock(&vlg_TlvEventDblock);
            return SNMP_ERR_GENERR;
    }
    //auto_unlock(&vlg_TlvEventDblock);
    return SNMP_ERR_NOERROR;
}
