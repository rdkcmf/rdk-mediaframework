/*
* If not stated otherwise in this file or this component's LICENSE file the
* following copyright and licenses apply:
*
* Copyright 2011 RDK Management
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "system.h"
#include "vlSnmpHostInfo.h"
#include "SnmpIORM.h"
/*sizeof system char variables can be changed later depeding on the system details*/
#define MAX_CHAR_SYSTEM 255 
/** Initializes the system module */
void
init_system(void)
{
    static oid      sysDescr_oid[] = { 1, 3, 6, 1, 2, 1, 1, 1 };
    static oid      sysObjectID_oid[] = { 1, 3, 6, 1, 2, 1, 1, 2 };
    static oid      sysUpTime_oid[] = { 1, 3, 6, 1, 2, 1, 1, 3 };
    static oid      sysContact_oid[] = { 1, 3, 6, 1, 2, 1, 1, 4 };
    static oid      sysName_oid[] = { 1, 3, 6, 1, 2, 1, 1, 5 };
    static oid      sysLocation_oid[] = { 1, 3, 6, 1, 2, 1, 1, 6 };
    static oid      sysServices_oid[] = { 1, 3, 6, 1, 2, 1, 1, 7 };
    static oid      sysORLastChange_oid[] = { 1, 3, 6, 1, 2, 1, 1, 8 };

    DEBUGMSGTL(("system", "Initializing\n"));
   
    SNMP_DEBUGPRINT("system :::::::::::::::::::::::;; Initializing\n");
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysDescr", handle_sysDescr, sysDescr_oid,
                             OID_LENGTH(sysDescr_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysObjectID", handle_sysObjectID,
                             sysObjectID_oid, OID_LENGTH(sysObjectID_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysUpTime", handle_sysUpTime, sysUpTime_oid,
                             OID_LENGTH(sysUpTime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysContact", handle_sysContact,
                             sysContact_oid, OID_LENGTH(sysContact_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysName", handle_sysName, sysName_oid,
                             OID_LENGTH(sysName_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysLocation", handle_sysLocation,
                             sysLocation_oid, OID_LENGTH(sysLocation_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysServices", handle_sysServices,
                             sysServices_oid, OID_LENGTH(sysServices_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysORLastChange", handle_sysORLastChange,
                             sysORLastChange_oid,
                             OID_LENGTH(sysORLastChange_oid),
                             HANDLER_CAN_RONLY));
}
#ifdef __cplusplus
extern "C" {
#endif

VL_SYSTEMINFO_t systemObj;
VL_SYSTEMINFO_t old_systemObj;
static char sysCn[MAX_CHAR_SYSTEM] = "Test";
static char sysNM[MAX_CHAR_SYSTEM] = "Test";
static char sysLOC[MAX_CHAR_SYSTEM] = "FREMONT";

static char old_sysCn[MAX_CHAR_SYSTEM] = "Test";
static char old_sysNM[MAX_CHAR_SYSTEM] = "Test";
static char old_sysLOC[MAX_CHAR_SYSTEM] = "FREMONT";
#ifdef __cplusplus
}
#endif



//memset(&systemObj,0,sizeof(VL_SYSTEMINFO_t));
int
handle_sysDescr(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
         if( (VL_HOST_SNMP_API_RESULT_SUCCESS !=  vl_SnmpHostSysteminfo(VL_SNMP_VAR_TYPE_sysDescr, &systemObj)))
        {
              SNMP_DEBUGPRINT("ERROR:Sget_gsysdecvar");
              return SNMP_ERR_GENERR;
        }
        SNMP_DEBUGPRINT("\n SYSDESCR ::::VLSYSTEM::::::::: %s \n", systemObj.gsysdecvar);
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 systemObj.gsysdecvar
                                 ,
                                 strlen(systemObj.gsysdecvar));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysDescr\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysObjectID(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        if( (VL_HOST_SNMP_API_RESULT_SUCCESS !=  vl_SnmpHostSysteminfo(VL_SNMP_VAR_TYPE_sysObjectID, &systemObj)))
        {
              SNMP_DEBUGPRINT("ERROR:VL_SNMP_VAR_TYPE_sysObjectID");
              return SNMP_ERR_GENERR;
        }
       // RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "VL_SNMP_VAR_TYPE_sysObjectID ::::::systemObj %d\n size-of OID %d lenght copy %d\n", sizeof(systemObj.gsysObjid), sizeof(oid),  sizeof(oid)*systemObj.objidlenght);
        snmp_set_var_typed_value(requests->requestvb, ASN_OBJECT_ID,
                                 (u_char *)systemObj.gsysObjid
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                  sizeof(oid)*systemObj.objidlenght /*sizeof(oid)*(sizeof(systemObj.gsysObjid)/(sizeof(oid)))*/ /*
                                  * XXX: the length of the data in bytes                                   */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysObjectID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysUpTime(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            /********************** VL CODE  start*********************/
            long uptime = get_uptime();
            /********************** VL CODE  end*********************/
            snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                    (u_char *)&uptime, sizeof(uptime));
        }
        break;
    
        default:
        {
            /*
            * we should never get here, so this is a really bad error 
            */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysUpTime\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
        }
        break;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysContact(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
         
       snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)sysCn
                                 /* pointer to the scalar's data */
                                 ,strlen(sysCn)
                                 /*
                                  * the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        //vlStrCpy(old_sysCn, sysCn, MAX_CHAR_SYSTEM);
        //RDK_LOG(RDK_LOG_DEBUG, "LOG.RDK.SNMP", "MODE_SET_RESERVE1 1:::old_sysCn= %s \t sysCn = %s \n", old_sysCn , sysCn);

        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;
 // #if 0
    case MODE_SET_RESERVE2:
       /*
         * XXX malloc "undo" storage buffer 
         */
//         if ( /* XXX if malloc, or whatever, failed: */ ) {
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_RESOURCEUNAVAILABLE);
//         }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
         break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        //vlStrCpy(old_sysCn, sysCn, MAX_CHAR_SYSTEM);
        //memset(sysCn, 0, MAX_CHAR_SYSTEM); 
        //vlStrCpy(sysCn, requests->requestvb->val.string, CHRMAX);

        SNMP_DEBUGPRINT(" MODE_SET_ACTION 4::old_systemObj.gsysContact = %s  systemObj.gsysContact =%s\n", old_sysCn , sysCn);
       
        SNMP_DEBUGPRINT(" MODE_SET_ACTION set value is systemObj.gsysContact %s \n", requests->requestvb->val.string);
        

        if ( requests->requestvb->val_len == 0 ) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE
                                      );
        }
        break;

    case MODE_SET_COMMIT:

        strncpy(sysCn, (char*)(requests->requestvb->val.string), MAX_CHAR_SYSTEM);
        sysCn[ MAX_CHAR_SYSTEM-1 ] = 0;
		
       /*snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)systemObj.gsysContact
                                 ,strlen(systemObj.gsysContact)
                                 );*/
        SNMP_DEBUGPRINT("MODE_SET_COMMIT set value issysCn%s", sysCn); 
        SNMP_DEBUGPRINT("MODE_SET_COMMIT 5:::old_sysCn %s  sysCn %s\n", old_sysCn , sysCn); 
        /*
         * XXX: delete temporary storage 
         */
//         if ( /* XXX: error? */ ) {
//             /*
//              * try _really_really_ hard to never get to this point 
//              */
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_COMMITFAILED);
//         }
        break;

    case MODE_SET_UNDO:
        //vlStrCpy(sysCn, old_sysCn, CHRMAX);
        SNMP_DEBUGPRINT("MODE_SET_UNDO 6:::old_sysCn %s  sysCn %s\n", old_sysCn , sysCn); 
        /*
         * XXX: UNDO and return to previous value for the object 
         */
//         if ( /* XXX: error? */ ) {
//             /*
//              * try _really_really_ hard to never get to this point 
//              */
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_UNDOFAILED);
//         }
        break;
   // #endif//if 0
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysContact\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysName(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)sysNM
                                 /* XXX: a pointer to the scalar's data */
                                 ,strlen(sysNM)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        //vlStrCpy(old_sysNM, (char*)sysNM, MAX_CHAR_SYSTEM);
        SNMP_DEBUGPRINT("MODE_SET_RESERVE1 1:::old_sysNM= %s \t sysNM = %s \n", old_sysNM , sysNM);

        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;
  // #if 0
    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
//          */
//         if ( /* XXX if malloc, or whatever, failed: */ ) {
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_RESOURCEUNAVAILABLE);
//         }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
         /*
         * XXX: perform the value change here 
         */
        //vlStrCpy(old_sysNM, (char*)sysNM, MAX_CHAR_SYSTEM);
        //memset(sysNM, 0, MAX_CHAR_SYSTEM); 
        //vlStrCpy(sysNM, (char*)requests->requestvb->val.string, CHRMAX);

        SNMP_DEBUGPRINT(" MODE_SET_ACTION 4::old_sysNM = %s  sysNM =%s\n", old_sysNM , sysNM);
       
        SNMP_DEBUGPRINT(" MODE_SET_ACTION set value is sysNM %s \n", requests->requestvb->val.string);
        

        if ( requests->requestvb->val_len == 0 ) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE
                                      );
        }
        break;
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        strncpy(sysNM, (char*)requests->requestvb->val.string, MAX_CHAR_SYSTEM);
        sysNM[ MAX_CHAR_SYSTEM-1 ] = 0;
        
        SNMP_DEBUGPRINT("MODE_SET_COMMIT set value sysNM%s", sysNM); 
        SNMP_DEBUGPRINT("MODE_SET_COMMIT 5:::old_sysNM %s  sysNM %s\n", old_sysNM , sysNM);
//         if ( /* XXX: error? */ ) {
//             /*
//              * try _really_really_ hard to never get to this point 
//              */
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_COMMITFAILED);
//         }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        //vlStrCpy(sysNM, (char*)old_sysNM, MAX_CHAR_SYSTEM);
        
        SNMP_DEBUGPRINT("MODE_SET_UNDO 6:::old_sysNM %s  sysNM %s\n", old_sysNM , sysNM); 
//         if ( /* XXX: error? */ ) {
//             /*
//              * try _really_really_ hard to never get to this point 
//              */
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_UNDOFAILED);
//         }
        break;
  // #endif //if 0
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysName\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
  
    return SNMP_ERR_NOERROR;
}

int
handle_sysLocation(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
         snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)sysLOC
                                 /* XXX: a pointer to the scalar's data */
                                 ,strlen(sysLOC)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        //vlStrCpy(old_sysLOC, (char*)sysLOC, MAX_CHAR_SYSTEM);
        
        SNMP_DEBUGPRINT("MODE_SET_RESERVE1 1:::old_sysLOC= %s \t sysLOC = %s \n", old_sysLOC , sysLOC); 
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;
  //#if 0
    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
//         if ( /* XXX if malloc, or whatever, failed: */ ) {
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_RESOURCEUNAVAILABLE);
//         }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        //vlStrCpy(old_sysLOC, (char*)sysLOC, MAX_CHAR_SYSTEM);
        //memset(sysLOC, 0, MAX_CHAR_SYSTEM); 
        //vlStrCpy(sysLOC, (char*)requests->requestvb->val.string, MAX_CHAR_SYSTEM);

        SNMP_DEBUGPRINT(" MODE_SET_ACTION 4::old_sysLOC = %s  sysLOC =%s\n", old_sysLOC, sysLOC);
       
        SNMP_DEBUGPRINT(" MODE_SET_ACTION set value is sysLOC %s \n", requests->requestvb->val.string);

        if (requests->requestvb->val_len == 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE
                                      );
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        strncpy(sysLOC, (char*)requests->requestvb->val.string, MAX_CHAR_SYSTEM);
        sysLOC[ MAX_CHAR_SYSTEM-1 ] = 0;
        
        SNMP_DEBUGPRINT("MODE_SET_COMMIT set value sysNM%s", sysLOC); 
        SNMP_DEBUGPRINT("MODE_SET_COMMIT 5:::old_sysNM %s  sysNM %s\n", old_sysLOC , sysLOC);
//         if ( /* XXX: error? */ ) {
//             /*
//              * try _really_really_ hard to never get to this point 
//              */
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_COMMITFAILED);
//         }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        //vlStrCpy(sysLOC, (char*)old_sysLOC, MAX_CHAR_SYSTEM);
        
        SNMP_DEBUGPRINT("MODE_SET_UNDO 6:::old_sysLOC %s  sysLOC %s\n", old_sysLOC , sysLOC); 
//         if ( /* XXX: error? */ ) {
//             /*
//              * try _really_really_ hard to never get to this point 
//              */
//             netsnmp_set_request_error(reqinfo, requests,
//                                       SNMP_ERR_UNDOFAILED);
//         }
        break;
    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysLocation\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysServices(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        if( (VL_HOST_SNMP_API_RESULT_SUCCESS !=  vl_SnmpHostSysteminfo(VL_SNMP_VAR_TYPE_sysServices, &systemObj)))
        {
              SNMP_DEBUGPRINT("ERROR:VL_SNMP_VAR_TYPE_sysServices");
              return SNMP_ERR_GENERR;
        } 
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&systemObj.gsysServices
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(systemObj.gsysServices)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysServices\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysORLastChange(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
         if( (VL_HOST_SNMP_API_RESULT_SUCCESS !=  vl_SnmpHostSysteminfo(VL_SNMP_VAR_TYPE_sysORLastChange, &systemObj)))
        {
              SNMP_DEBUGPRINT("ERROR:VL_SNMP_VAR_TYPE_sysORLastChange");
              return SNMP_ERR_GENERR;
        } 
        snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                 (u_char *)&systemObj.gsysORLastChange
                                 /* XXX: a pointer to the scalar's data */
                                 ,sizeof(systemObj.gsysORLastChange)
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysORLastChange\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
